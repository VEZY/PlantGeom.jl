var documenterSearchIndex = {"docs":
[{"location":"plot_diagram/makie_diagram/#Makie.jl-recipes","page":"Makie.jl","title":"Makie.jl recipes","text":"","category":"section"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")\nusing PlantGeom\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))","category":"page"},{"location":"plot_diagram/makie_diagram/#Diagram","page":"Makie.jl","title":"Diagram","text":"","category":"section"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"We can make a diagram of the MTG graph using the diagram function:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"using PlantGeom, CairoMakie\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\ndiagram(opf)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"We can change the color of the nodes:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"diagram(opf, color = :palegreen1)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"The color argument is for the node color. The edges are colored with the same color than the nodes by default, but you can also use a different color if you want using edge_color:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"diagram(opf, color = :palegreen1, edge_color = :sienna)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"You can also color your nodes based on an attribute from the MTG, e.g. using the nodes Z coordinates:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"# First, we compute \"fake\" coordinates for each node in the MTG (just for ploting):\nPlantGeom.coordinates!(opf, force = true)\n# Then we plot the MTG using the newly created ZZ attribute:\ndiagram(opf, color = :YY)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"We can also color the edges differently, e.g. using the XX attribute computed using coordinates!:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"PlantGeom.coordinates!(opf, force = true)\ndiagram(opf, color = :YY, edge_color = :XX)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"Attributes used for coloring may have missing values. In this case you can choose their color using color_missing, e.g.:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"diagram(opf, color = :Length, edge_color = :Width, color_missing = :red)","category":"page"},{"location":"plot_diagram/plots_diagram/#Plots.jl-recipes","page":"Plots.jl","title":"Plots.jl recipes","text":"","category":"section"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"using PlantGeom\nusing Plots\nplotlyjs()\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"PlantGeom.jl provides recipes to make plots using Plots.jl. The only recipe so far is to make a diagram of the MTG tree. This is especially useful to control the integrity of and MTG (where it branches, where are the different scales...).","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"To use this recipe, simply use Plots.jl and any backend, though we recommend PlotlyJS to make the plot interactive.","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"The plot recipe provides some arguments to customize the plot:","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"mode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"using Plots\n# import Pkg; Pkg.add(\"PlotlyJS\")\nplotlyjs()\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\nplot(opf, node_color = :Length)\nsavefig(\"mtgplot.html\"); nothing # hide","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"<object type=\"text/html\" data=\"mtgplot.html\" style=\"width:100%;height:500px;\"></object>","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"The default plot is a 2D projection of the MTG, but you can also get a 3D projection using the mode keyword argument:","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"plot(opf, node_color = :Length, mode = \"3d\")\nsavefig(\"mtgplot3d.html\"); nothing # hide","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"<object type=\"text/html\" data=\"mtgplot3d.html\" style=\"width:100%;height:500px;\"></object>","category":"page"},{"location":"makie_3d/#3D-plots-(meshes)","page":"3D Makie recipes","title":"3D plots (meshes)","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"PlantGeom uses Makie.jl to make 3d mesh plots. It also uses MeshViz.jl that is also based on Makie.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"This way the plots you make using PlantGeom support all the nice possibilities offered by Makie, such as making sub-plots, interactive plots...","category":"page"},{"location":"makie_3d/#Interactive-plot","page":"3D Makie recipes","title":"Interactive plot","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Here comes the fun part! We can make 3D representations of the plants based on the geometry of each of its nodes.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"If you read your MTG from an OPF file, the 3D geometry should already be computed, so you just have to viz() the MTG.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Because we're plotting the interactive plot in the webpage, we must use JSServe first (no need when using Julia from the REPL or VS Code):","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using JSServe\nPage(exportable=true, offline=true)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Then we can plot our interactive 3D plant:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using PlantGeom, WGLMakie\nWGLMakie.activate!() # hide\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\nviz(mtg)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"warning: Warning\nThe plot may take some time to appear on your screen.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Note that the plot is interactive. This is because we use WGLMakie as a plotting backend. You can also use GLMakie for better performance, or CairoMakie if you want a fast, non-interactive plot.","category":"page"},{"location":"makie_3d/#Colors","page":"3D Makie recipes","title":"Colors","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using PlantGeom, CairoMakie, MultiScaleTreeGraph\nCairoMakie.activate!()\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\"))\ntransform!(mtg, refmesh_to_mesh!)\nref_meshes = get_ref_meshes(mtg);\ntransform!(mtg, :Area => (x -> [x*i for i in 1:12]) => :dummy_var, ignore_nothing = true)","category":"page"},{"location":"makie_3d/#Note-about-the-backend","page":"3D Makie recipes","title":"Note about the backend","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"In this section, we will use the coffee plant provided as an example OPF file from the package. This one is more realistic than the tiny plant shown above. But because it is bigger, we will only provide static images instead of interactive plots. If you want to plot the interactive plots, you can execute the example code from below using GLMakie or WGLMakie instead of CairoMakie simply by replacing:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using CairoMakie","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"By:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using GLMakie","category":"page"},{"location":"makie_3d/#Set-up","page":"3D Makie recipes","title":"Set-up","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"The first step is to compute the node meshes using the reference meshes and the transformation matrices. This is done very easily by mapping refmesh_to_mesh! to each node of the MTG like so:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using MultiScaleTreeGraph\ntransform!(mtg, refmesh_to_mesh!)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"note: Note\nThis step is optional, and not needed if only few plots are performed because it is done automatically when plotting an MTG, but the results are discarded afterward to avoid too much memory usage. If you plant to make many plots, we advise to do this step to avoid to wait a long time each time.","category":"page"},{"location":"makie_3d/#Default-colors","page":"3D Makie recipes","title":"Default colors","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"The default behavior of viz(mtg) -without providing colors- is to use the color of each reference mesh as the color of the corresponding node mesh. In other words, a leaf in a tree will be colored with the same color as the reference mesh used to represent it. This reference mesh is available as an attribute in the root node of the MTG. We can extract those reference meshes like so:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"using PlantGeom, CairoMakie\nCairoMakie.activate!()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\nmtg = read_opf(file)\n\nref_meshes = get_ref_meshes(mtg)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Then we can plot them in sequence:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"viz(ref_meshes)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Here we are looking at the reference meshes used to build the plant. Those meshes are then transformed by transformation matrices from each node to make the mesh of that node. So by default the color used for the nodes will be taken from these reference meshes.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"If we plot the coffee plant without providing any color, we would get:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"viz(mtg)","category":"page"},{"location":"makie_3d/#Single-color","page":"3D Makie recipes","title":"Single color","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Now we can change the color of all meshes by providing a single color:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"viz(mtg, color = :gray87)","category":"page"},{"location":"makie_3d/#Map-color-to-reference-meshes","page":"3D Makie recipes","title":"Map color to reference meshes","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"We can also associate a new color to each reference mesh.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"We can get the default color of each reference mesh by using:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"get_ref_meshes_color(ref_meshes)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Now we know the first reference mesh is the cylinder (it is brown) and the second one is the leaf (it is green).","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"To update their colors we can simply pass the new colors as a dictionary mapping colors to reference meshes like so:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"viz(mtg, color = Dict(1 => :gray87, 2 => \"#42A25ABD\"))","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"If we want to update the second reference mesh only (the leaves), we would do:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"viz(mtg, color = Dict(2 => \"#42A25ABD\"))","category":"page"},{"location":"makie_3d/#Map-color-to-attributes","page":"3D Makie recipes","title":"Map color to attributes","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Maybe the most interesting coloring option is to color by attribute.","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Indeed, each node in the MTG can have specific attributes, e.g. an area, a temperature...","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"You can see which attributes are available in an MTG using:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"print(names(mtg))","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"We can see that we have an attribute called :Area. Let's color each organ by its area:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"viz(mtg, color = :Area)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Of course all Makie commands are available. For example we can zoom-in the plot using scale!, and add a colorbar:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"f, ax, p = viz(mtg, color = :Area)\nCairoMakie.scale!(p, 1.5, 1.5, 1.5) # we zoom-in a little bit\nCairoMakie.Colorbar(f[1,2], label = \"Area\")\nf","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"We can see that the colorbar is only in relative values (0-1). If you need absolute values, you can use PlantGeom's colorbar instead:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"f, ax, p = viz(mtg, color = :Area)\ncolorbar(f[1, 2], p)\nf","category":"page"},{"location":"makie_3d/#Map-color-to-vertices","page":"3D Makie recipes","title":"Map color to vertices","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"# Compute the z position of each vertices in each mesh:\ntransform!(mtg, :geometry => (x -> [i.coords[3] for i in x.mesh.vertices]) => :z, ignore_nothing = true)\nviz(mtg, color = :z, showfacets = true, color_vertex = true)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"note: Note\nThis one is not shown because CairoMakie and WGLMakie are not compatible with coloring each vertices differently. But you can still see the results on your computer using GLMakie.","category":"page"},{"location":"makie_3d/#Map-time-step-to-color","page":"3D Makie recipes","title":"Map time step to color","text":"","category":"section"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"The MTG attributes can have several values, for example a value for each time step of a simulation. For example, let's make a dummy variable with 12 time-steps, each value being the area time the time step:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"transform!(mtg, :Area => (x -> [x*i for i in 1:12]) => :dummy_var, ignore_nothing = true)","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"Now we can plot the plant with the color of each organ being the value of the dummy variable at time step 1 using the index keyword argument:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"f, ax, p = viz(mtg, color = :dummy_var, index = 1)\ncolorbar(f[1, 2], p)\nf","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"We can even make a video out of it:","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"f, ax, p = viz(mtg, color = :dummy_var, index = 1)\ncolorbar(f[1, 2], p)\n\nrecord(f, \"coffee_steps.mp4\", 1:12, framerate=2) do timestep\n    p.index[] = timestep\nend","category":"page"},{"location":"makie_3d/","page":"3D Makie recipes","title":"3D Makie recipes","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantGeom","category":"page"},{"location":"#PlantGeom","page":"Home","title":"PlantGeom","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PlantGeom, a package about everything 3D-related for plants.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed around MultiScaleTreeGraph for the basic structure of plants (or any 3D object) topology and attributes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package provides different functionalities, the main ones being:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IO for the OPF file format (see read_opf and write_opf);\nplotting using viz and viz!, optionally using coloring by attribute;\nmesh transformations using transform_mesh!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that PlantGeom reserves the :geometry attribute in the nodes (e.g. organs). It uses it to store the 3D geometry as a special structure (geometry).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie, PlantGeom, MultiScaleTreeGraph # Note: CairoMakie must be loaded before PlantGeom to access the extensions\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\n\n# First, we compute the 3D coordinates for each node in the MTG:\ntransform!(opf, refmesh_to_mesh!)\n# And compute the max z of each node based on their mesh:\ntransform!(opf, zmax => :z_node, ignore_nothing = true)\n# Or the z coordinate of each vertez of each node mesh:\ntransform!(opf, :geometry => (x -> [i.coords[3] for i in x.mesh.vertices]) => :z_vertex, ignore_nothing = true)\n\n\n# Then we make a Makie figure:\nf = Figure()\nga = f[1, 1]\ngb = f[1, 2]\n\nax1 = Axis(ga[1, 1])\nax2 = Axis3(gb[1, 1], aspect = :data, title = \"3D representation (mesh)\", elevation = 0.15π, azimuth = 0.3π)\nhidedecorations!(ax2)\n\n# We can make a diagram out of the MTG, and coloring using the z coordinates attribute:\ndiagram!(ax1, opf, color = :z_node)\nhidedecorations!(ax1)\nax1.title = \"MultiscaleTreeGraph diagram\"\n\n# And a 3d representation:\n\nviz!(opf, color = :z_vertex)\n\n# And making a little animation out of it:\nCairoMakie.record(f, \"plant_animation.mp4\", 1:120) do frame\n    ax2.azimuth[] = 0.3π + 0.3 * sin(2π * frame / 120)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to reproduce the animation, you can look at the code below. Otherwise, please head to the next section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantGeom, MultiScaleTreeGraph, CairoMakie\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\n\n# First, we compute the 3D coordinates for each node in the MTG:\ntransform!(opf, refmesh_to_mesh!)\n# And compute the max z of each node based on their mesh:\ntransform!(opf, zmax => :z_node, ignore_nothing = true)\n# Or the z coordinate of each vertez of each node mesh:\ntransform!(opf, :geometry => (x -> [i.coords[3] for i in x.mesh.vertices]) => :z_vertex, ignore_nothing = true)\n\n\n# Then we make a Makie figure:\nf = Figure()\nga = f[1, 1]\ngb = f[1, 2]\n\nax1 = Axis(ga[1, 1])\nax2 = Axis3(gb[1, 1], aspect = :data, title = \"3D representation (mesh)\", elevation = 0.15π, azimuth = 0.3π)\nhidedecorations!(ax2)\n\n# We can make a diagram out of the MTG, and coloring using the z coordinates attribute:\ndiagram!(ax1, opf, color = :z_node)\nhidedecorations!(ax1)\nax1.title = \"MultiscaleTreeGraph diagram\"\n\n# And a 3d representation:\n\nviz!(opf, color = :z_vertex)\n\n# And making a little animation out of it:\nCairoMakie.record(f, \"plant_animation.mp4\", 1:120) do frame\n    ax2.azimuth[] = 0.3π + 0.3 * sin(2π * frame / 120)\nend","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantGeom]","category":"page"},{"location":"API/#PlantGeom.Material","page":"API","title":"PlantGeom.Material","text":"A material for the illumination model (e.g. Phong illumination).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.Phong","page":"API","title":"PlantGeom.Phong","text":"Data structure for a mesh material that is used to describe the light components of a Phong reflection type model. All data is stored as RGBα for Red, Green, Blue and transparency.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.RefMesh","page":"API","title":"PlantGeom.RefMesh","text":"RefMesh(\n    name::S\n    mesh::SimpleMesh\n    normals::N\n    texture_coords::T\n    material::M\n    taper::Bool\n)\n\nRefMesh(name, mesh, material = RGB(220 / 255, 220 / 255, 220 / 255))\n\nRefMesh type. Stores all information about a Mesh:\n\nname::S: the mesh name\nmesh::SimpleMesh: the actual mesh information -> points and topology\nnormals::Vector{Float64}: the normals, given as a vector of x1,y1,z1,x2,y2,z2...\ntexture_coords::Vector{Float64}: the texture coordinates (not used yet), idem, a vector\nmaterial::M: the material, used to set the shading\ntaper::Bool: true if tapering is enabled\n\nThe reference meshes are then transformed on each node of the MTG using a transformation matrix to match the actual mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.RefMeshes","page":"API","title":"PlantGeom.RefMeshes","text":"RefMeshes type. Data base that stores all RefMesh in an MTG. Usually stored in the :ref_meshes attribute of the root node.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.geometry","page":"API","title":"PlantGeom.geometry","text":"geometry(; ref_mesh<:RefMesh, ref_mesh_index=nothing, transformation=Identity(), dUp=1.0, dDwn=1.0, mesh::Union{SimpleMesh,Nothing}=nothing)\n\nA Node geometry with the reference mesh, its transformation (as a function) and optionnally the index of the reference mesh in the reference meshes data base (see notes) and the resulting mesh (optional to save memory).\n\nNote\n\nThe refmesh usually points to a RefMesh stored in the `:refmeshes` attribute of the root node of the MTG.\n\nAlthough optional, storing the index of the reference mesh (ref_mesh_index) in the database allows a faster writing of the MTG as an OPF to disk.\n\nThe transformation field should be a TransformsBase.Transform, such as TransformsBase.Identity, or the ones implemented in  Meshes.jl, e.g. Translate, Scale... If you already have the transformation matrix, you can pass it to Meshes.Affine(). \n\n\n\n\n\n","category":"type"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:PlantGeom.geometry","page":"API","title":"Base.:==","text":"==(a::geometry, b::geometry)\n\nTest RefMeshes equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:RefMesh","page":"API","title":"Base.:==","text":"==(a::RefMesh, b::RefMesh)\n\nTest RefMesh equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:RefMeshes","page":"API","title":"Base.:==","text":"==(a::RefMeshes, b::RefMeshes)\n\nTest RefMeshes equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nelements-Tuple{RefMeshes}","page":"API","title":"Meshes.nelements","text":"nelements(meshes::RefMeshes)\n\nReturn the number of elements for each reference mesh as a vector of nelements\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nelements-Tuple{RefMesh}","page":"API","title":"Meshes.nelements","text":"nelements(meshes::RefMeshes)\n\nReturn the number of elements of a reference mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nvertices-Tuple{RefMeshes}","page":"API","title":"Meshes.nvertices","text":"nvertices(meshes::RefMeshes)\n\nReturn the number of vertices for each reference mesh as a vector of nvertices\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nvertices-Tuple{RefMesh}","page":"API","title":"Meshes.nvertices","text":"nvertices(meshes::RefMesh)\n\nReturn the number of vertices of a reference mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.align_ref_meshes-Tuple{RefMeshes}","page":"API","title":"PlantGeom.align_ref_meshes","text":"align_ref_meshes(meshes::RefMeshes)\n\nAlign all reference meshes along the X axis. Used for visualisation only.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.attributes_to_xml-NTuple{4, Any}","page":"API","title":"PlantGeom.attributes_to_xml","text":"attributes_to_xml(node, xml_parent)\n\nWrite an MTG node into an XML node.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.color_type-Union{Tuple{T}, Tuple{T, Any}} where T<:Symbol","page":"API","title":"PlantGeom.color_type","text":"color_type(color, opf)\n\nReturn the type of the color, whether it is an attribute, a colorant, or a RefMeshColorant.\n\nArguments\n\ncolor: The color to be checked.\nopf: The MTG to be plotted.\n\nReturns\n\nRefMeshColorant: If the color is :slategray3, then it is the default color given by Meshes,\n\nso we assume nothing was passed by the user and color by reference mesh instead.\n\nAttributeColorant: If the color is an attribute of the MTG, then we color by that attribute.\nT: If the color is a colorant, then we color everything by that color.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, Colors\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n\nopf = read_opf(file)\n\n# Colors:\ncolor_type(:red, opf)\ncolor_type(RGB(0.1,0.5,0.1), opf)\n\n# Attributes:\ncolor_type(:Length, opf)\n\n# Default color:\ncolor_type(:slategray3, opf)\n\n# Dict of colors:\ncolor_type(Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.5,0.1,0.1)), opf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.colorant_to_string-Tuple{T} where T<:ColorTypes.RGBA","page":"API","title":"PlantGeom.colorant_to_string","text":"colorant_to_string(x)\n\nParse a geometry material for OPF writing.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.coordinates!-Tuple{Any}","page":"API","title":"PlantGeom.coordinates!","text":"coordinates!(mtg; angle = 45; force = false)\n\nCompute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.\n\nReturns\n\nNothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncoordinates!(mtg)\nDataFrame(mtg, [:XX, :YY, :ZZ])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.diagram","page":"API","title":"PlantGeom.diagram","text":"diagram(opf::MultiScaleTreeGraph.Node; kwargs...)\ndiagram!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree using a Makie.jl backend.\n\ndanger: Danger\nThis function is an extension to the package. It is only available if you imported a Makie backend (e.g. using GLMakie) prior to using PlantGeom.\n\nThe main attributes are:\n\ncolor: the color of the nodes\ncolormap: the colormap used if the color uses an attribute. By default it uses viridis.\n\nMust be a ColorScheme from ColorSchemes or a Symbol with its name.\n\nExamples\n\nusing GLMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\ndiagram(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\ndiagram(opf, color = :red)\n\n# Or colouring by opf attribute, *e.g.* using the nodes Z coordinates:\ndiagram(opf, color = :ZZ)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.diagram!","page":"API","title":"PlantGeom.diagram!","text":"diagram(opf::MultiScaleTreeGraph.Node; kwargs...)\ndiagram!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree using a Makie.jl backend.\n\ndanger: Danger\nThis function is an extension to the package. It is only available if you imported a Makie backend (e.g. using GLMakie) prior to using PlantGeom.\n\nThe main attributes are:\n\ncolor: the color of the nodes\ncolormap: the colormap used if the color uses an attribute. By default it uses viridis.\n\nMust be a ColorScheme from ColorSchemes or a Symbol with its name.\n\nExamples\n\nusing GLMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\ndiagram(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\ndiagram(opf, color = :red)\n\n# Or colouring by opf attribute, *e.g.* using the nodes Z coordinates:\ndiagram(opf, color = :ZZ)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.extend_pos-NTuple{5, Any}","page":"API","title":"PlantGeom.extend_pos","text":"Add a new point after (x1,y1) using same direction and length relative to it\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_attr_type-Tuple{Any}","page":"API","title":"PlantGeom.get_attr_type","text":"Get the attributes types in Julia DataType.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_color-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Nothing}} where T<:AbstractArray","page":"API","title":"PlantGeom.get_color","text":"get_color(var <: AbstractArray, range_var, colormap=colorschemes[:viridis])\nget_color(var, range_var, colormap=colorschemes[:viridis])\n\nMap value(s) to colors from a colormap based on a range of values\n\nArguments\n\nvar: value(s) to map to colors\nrange_var: range of values to map to colors\ncolormap: colormap to use\n\nReturns\n\ncolor: color(s) corresponding to var\n\nExamples\n\n```julia using Colors\n\ngetcolor(1, 1:2, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415) getcolor(1:2, 1:10, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415) get_color(1:2, 1:10, 1, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_colormap-Tuple{Any}","page":"API","title":"PlantGeom.get_colormap","text":"get_colormap(colormap)\n\nGet the colormap as a ColorScheme if it is a named color or ColorScheme\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_mtg_color-Tuple{Any, Any}","page":"API","title":"PlantGeom.get_mtg_color","text":"get_mtg_color(color, opf)\n\nReturn the color to be used for the plot.\n\nArguments\n\ncolor: The color to be checked.\nopf: The MTG to be plotted.\n\nReturns\n\nThe color to be used for the plot.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, Colors\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nget_mtg_color(:red, opf)\nget_mtg_color(RGB(0.1,0.5,0.1), opf)\nget_mtg_color(:Length, opf)\nget_mtg_color(:slategray3, opf)\nget_mtg_color(Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.1,0.1,0.5)), opf)\nget_mtg_color(Dict(1 => :burlywood4, 2 => :springgreen4), opf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_mesh_index","page":"API","title":"PlantGeom.get_ref_mesh_index","text":"get_ref_mesh_index!(node, ref_meshes = get_ref_meshes(node))\nget_ref_mesh_index(node, ref_meshes = get_ref_meshes(node))\n\nGet the index of the reference mesh used in the current node.\n\nNotes\n\nPlease use the ref_meshes argument preferably as not giving it make the function visit the root node each time otherwise, and it can become a limitation when traversing a big MTG.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.get_ref_mesh_index!","page":"API","title":"PlantGeom.get_ref_mesh_index!","text":"get_ref_mesh_index!(node, ref_meshes = get_ref_meshes(node))\nget_ref_mesh_index(node, ref_meshes = get_ref_meshes(node))\n\nGet the index of the reference mesh used in the current node.\n\nNotes\n\nPlease use the ref_meshes argument preferably as not giving it make the function visit the root node each time otherwise, and it can become a limitation when traversing a big MTG.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.get_ref_meshes-Tuple{Any}","page":"API","title":"PlantGeom.get_ref_meshes","text":"get_ref_meshes(mtg)\n\nGet all reference meshes from an mtg, usually from an OPF.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\n\nusing GLMakie\nviz(meshes)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_meshes_color-Tuple{RefMeshes}","page":"API","title":"PlantGeom.get_ref_meshes_color","text":"get_ref_meshes_color(meshes::RefMeshes)\n\nGet the reference meshes colors (only the diffuse part for now).\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\nPlantGeom.get_ref_meshes_color(meshes)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.map_coord-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.map_coord","text":"map_coord(f, mesh, coord)\n\nApply function f over the mesh coordinates coord. Values for coord can be 1 for x, 2 for y and 3 for z.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.materialBDD_to_material-Tuple{Any}","page":"API","title":"PlantGeom.materialBDD_to_material","text":"Parse a material in opf format to a Phong material.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.material_to_opf_string-Tuple{Phong}","page":"API","title":"PlantGeom.material_to_opf_string","text":"material_to_opf_string(material::Phong)\nmaterial_to_opf_string(material::Colorant)\n\nFormat a material into a Dict for OPF writting.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.meshBDD_to_meshes-Tuple{Any}","page":"API","title":"PlantGeom.meshBDD_to_meshes","text":"meshBDD_to_meshes(x)\n\nExamples\n\nusing MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshBDD_to_meshes(opf[:meshBDD])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.mtg_coordinates_df","page":"API","title":"PlantGeom.mtg_coordinates_df","text":"mtg_coordinates_df(mtg, attr; force = false)\nmtg_coordinates_df!(mtg, attr; force = false)\n\nExtract the coordinates of the nodes of the mtg and the coordinates of their parents (:XXfrom, :YYfrom, :ZZ_from) and output a DataFrame. Optionally you can also provide an attribute to add to the output DataFrame too by passing its name as a symbol to attr.\n\nThe coordinates are computed using coordinates! if missing, or if force = true.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.mtg_to_opf_link-Tuple{Any}","page":"API","title":"PlantGeom.mtg_to_opf_link","text":"mtg_to_opf_link(link)\n\nTakes an MTG link as input (\"/\", \"<\" or \"+\") and outputs its corresponding link as declared in the OPF format (\"decomp\", \"follow\" or \"branch\")\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.mtg_topology_to_xml!","page":"API","title":"PlantGeom.mtg_topology_to_xml!","text":"mtg_topology_to_xml!(node, xml_parent)\n\nWrite the MTG topology, attributes and geometry into XML format. This function is used to write the \"topology\" section of the OPF.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.normals_vertex-Tuple{RefMesh}","page":"API","title":"PlantGeom.normals_vertex","text":"normals_vertex(mesh::Meshes.SimpleMesh)\n\nCompute per vertex normals and return them as a StaticArrays.SVector.\n\n#! This is a naive approach because I have no time right know. #! We just put the face mesh as a vertex mesh (and ovewritting values for common points)\n\nTODO: Use a real computation instead. See e.g.:\n\nhttps://stackoverflow.com/questions/45477806/general-method-for-calculating-smooth-vertex-normals-with-100-smoothness?noredirect=1&lq=1\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_geometry-Tuple{Any}","page":"API","title":"PlantGeom.parse_geometry","text":"Parse the geometry element of the OPF.\n\nNote\n\nThe transformation matrix is 3*4. elem = elem.content\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_materialBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_materialBDD!","text":"Parse the materialBDD using parse_opf_elements!\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_meshBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_meshBDD!","text":"Parse the meshBDD using parse_opf_array\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_array","page":"API","title":"PlantGeom.parse_opf_array","text":"Parse an array of values from the OPF into a Julia array (Arrays in OPFs are not following XML recommendations)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.parse_opf_attributeBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_opf_attributeBDD!","text":"Parse the opf attributes as a Dict.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_elements!-Tuple{Any, Any}","page":"API","title":"PlantGeom.parse_opf_elements!","text":"Generic parser for OPF elements.\n\nArguments\n\nopf::OrderedDict: the opf Dict (using [XMLDict.xml_dict])\nelem_types::Array: the target types of the element (e.g. \"[String, Int64]\")\n\nDetails\n\nelem_types should be of the same length as the number of elements found in each item of the subchild. elem_types = [Float64, Float64, Float64, Float64, Float64, Float64]\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_topology!","page":"API","title":"PlantGeom.parse_opf_topology!","text":"parse_opf_topology!(node, mtg, features, attr_type, mtg_type, ref_meshes, id_set=Set{Int}())\n\nParser of the OPF topology.\n\nArguments\n\nnode::ElementNode: the XML node to parse.\nmtg::Union{Nothing,Node}: the parent MTG node.\nfeatures::Dict: the features of the OPF.\nattr_type::DataType: the type of the attributes to use.\nmtg_type::DataType: the type of the MTG to use.\nref_meshes::Dict: the reference meshes.\nread_id::Bool: whether to read the ID from the OPF or recompute it on the fly.\nmax_id::RefValue{Int64}=Ref(1): the ID of the first node, if read_id==false.\n\nNote\n\nThe transformation matrices in geometry are 3*4.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.parse_ref_meshes-Tuple{Any}","page":"API","title":"PlantGeom.parse_ref_meshes","text":"parse_ref_meshes(mtg)\n\nParse the reference meshes of an OPF into RefMeshes.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_opf-Tuple{Any}","page":"API","title":"PlantGeom.read_opf","text":"read_opf(file; attr_type = Dict, mtg_type = MutableNodeMTG)\n\nRead an OPF file, and returns an MTG.\n\nArguments\n\nfile::String: The path to the opf file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nread_id::Bool = true: whether to read the ID from the OPF or recompute it on the fly.\nmax_id::RefValue{Int64}=Ref(1): the ID of the first node, if read_id==false.\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attributes a lot\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify  anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the MTG package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\nopf = read_opf(file)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_ops-Tuple{Any}","page":"API","title":"PlantGeom.read_ops","text":"read_ops(file; attr_type=Dict{String,Any}, mtg_type=MutableNodeMTG)\n\nReads an OPS file and returns the content as a MultiScaleTreeGraph.\n\nArguments\n\nfile::String: Path of the .ops file to read.\nattr_type::Type=Dict{Symbol,Any}: Type of the attributes to use.\nmtg_type::Type: Type of the MTG to use, e.g. NodeMTG or MutableNodeMTG.\n\nReturns\n\nA MultiScaleTreeGraph of the scene, with the OPFs as children of the scene node. The dimension of the scene is available in the scene_dimensions attribute of the scene node. Each root node of the OPFs has a scene_transformation attribute that stores the transformation applied to the OPF by the scene. It allows updating the scene transformations and write the scene back to disk. The OPF root node also has the following attributes:\n\nsceneID::Int: Scene ID.\nplantID::Int: Plant ID.\nfilePath::String: Path to the original .opf file.\npos::Meshes.Point3: Position of the object.\nscale::Float64: Scale of the object.\ninclinationAzimut::Float64: Inclination azimut of the object.\ninclinationAngle::Float64: Inclination angle of the object.\nrotation::Float64: Rotation of the object.\nfunctional_group::String: Functional group of the object.\n\nDetails\n\nNode IDs of the OPFs are recomputed at import to ensure their uniqueness in the larger scene MTG.\n\nExample\n\nusing CairoMakie, PlantGeom\njoinpath(pathof(PlantGeom) |> dirname |> dirname, \"test\", \"files\", \"scene.ops\") |> read_ops |> viz\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_ops_file-Tuple{Any}","page":"API","title":"PlantGeom.read_ops_file","text":"read_ops_file(file)\n\nRead the content of an .ops file and return a tuple with the scene dimensions and the object table.\n\nArguments\n\nfile::String: Path of the .ops file to read.\n\nReturns\n\nThe scene dimensions and the object table as a tuple. The scene dimensions are a tuple of two Meshes.Point3 with the origin point and opposite point of the scene.  The object table is an array of NamedTuple with the following fields:\n\nsceneID::Int: Scene ID.\nplantID::Int: Plant ID.\nfilePath::String: Path to the .opf file.\npos::Meshes.Point3: Position of the object.\nscale::Float64: Scale of the object.\ninclinationAzimut::Float64: Inclination azimut of the object.\ninclinationAngle::Float64: Inclination angle of the object.\nrotation::Float64: Rotation of the object.\nfunctional_group::String: Functional group of the object.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.refmesh_to_mesh","page":"API","title":"PlantGeom.refmesh_to_mesh","text":"refmesh_to_mesh!(node)\nrefmesh_to_mesh(node)\n\nCompute a node mesh based on the reference mesh, the transformation matrix and the tapering. The mutating version adds the new mesh to the mesh field of the geometry attribute of the node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nnode = opf[1][1][1]\n\nnew_mesh = refmesh_to_mesh(node)\n\nusing GLMakie\nviz(new_mesh)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.refmesh_to_mesh!","page":"API","title":"PlantGeom.refmesh_to_mesh!","text":"refmesh_to_mesh!(node)\nrefmesh_to_mesh(node)\n\nCompute a node mesh based on the reference mesh, the transformation matrix and the tapering. The mutating version adds the new mesh to the mesh field of the geometry attribute of the node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nnode = opf[1][1][1]\n\nnew_mesh = refmesh_to_mesh(node)\n\nusing GLMakie\nviz(new_mesh)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.rotate_point-NTuple{5, Any}","page":"API","title":"PlantGeom.rotate_point","text":"Rotate a point (x1,y1) around (x0, y0) with angle.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.taper-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.taper","text":"Returns a tapered mesh using dDwn and dUp based on the geometry of an input mesh. Tapering a mesh transforms it into a tapered version (i.e. pointy) or enlarged object, e.g. make a cone from a cylinder.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.transform_mesh!-Tuple{MultiScaleTreeGraph.Node, Any}","page":"API","title":"PlantGeom.transform_mesh!","text":"transform_mesh!(node::Node, transformation)\n\nAdd a new transformation to the node geometry transformation field.  The transformation is composed with the previous transformation if any.\n\ntransformation must be a function.\n\nIt is also possible to invert a transformation using revert from Meshes.jl.\n\nExamples\n\nusing PlantGeom, MultiScaleTreeGraph, GLMakie, Rotations, Meshes\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"simple_plant.opf\")\nopf = read_opf(file)\n\n# Visualize the mesh as is:\nviz(opf)\n\n# Copy the OPF, and translate the whole plant by 15 in the y direction (this is in cm, the mesh comes from XPlo):\nopf2 = deepcopy(opf)\ntransform!(opf2, x -> transform_mesh!(x, Translate(0, 15, 0)))\nviz!(opf2) # Visualize it again in the same figure\n\n# Same but rotate the whole plant around the X axis:\nopf3 = deepcopy(opf)\ntransform!(opf3, x -> transform_mesh!(x, Rotate(RotX(0.3))))\n# NB: we use Rotations.jl's RotX here. Input in radian, use rad2deg and deg2rad if needed.\nviz!(opf3)\n\n# Same but rotate only the second leaf around the Z axis:\nopf4 = deepcopy(opf)\n# Build the meshes from the reference meshes (need it because we want the coordinates of the parent):\ntransform!(opf4, refmesh_to_mesh!)\n\n# Get the second leaf in the OPF:\nleaf_node = get_node(opf4, 8)\n\n# Get the parent node (internode) Z coordinates:\nparent_zmax = zmax(leaf_node.parent)\n\n# Define a rotation of the mesh around the Z axis defined by the parent node max Z:\ntransformation = recenter(Rotate(RotZ(1.0)), Point3(0.0, 0.0, parent_zmax))\n\n# Update the transformation matrix of the leaf and its mesh:\ntransform_mesh!(leaf_node, transformation)\n\n# Plot the result:\nviz(opf)\nviz!(opf4)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.write_opf-Tuple{Any, Any}","page":"API","title":"PlantGeom.write_opf","text":"write_opf(file, opf)\n\nWrite an MTG with explicit geometry to disk as an OPF file.\n\nNotes\n\nNode attributes :ref_meshes and :geometry are treated as reserved keywords and should not be used without knowing their meaning:\n\n:ref_meshes: a RefMeshes structure that holds the MTG reference meshes.\n:geometry: a geometry instance\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nwrite_opf(\"test.opf\", opf)\nopf2 = read_opf(\"test.opf\")\nviz(opf2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.write_ops-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.write_ops","text":"write_ops(file, scene_dimensions, object_table)\n\nWrite a scene file (.ops), with the given dimensions and object table.\n\nArguments\n\nfile::String: Path of the .ops file to write.\nscene_dimensions::Tuple{Meshes.Point{3,T},Meshes.Point{3,T}}: Dimensions of the scene.\nobject_table: Table with the objects to write in the .ops file. The table may have the following columns:\nsceneID::Int: Scene ID (mandatory).\nplantID::Int: Plant ID (mandatory).\nfilePath::String: Path to the .opf file (mandatory).\npos::Meshes.Point{3,T}: Position of the object (mandatory).\nfunctional_group::String: Functional group of the object, used to map the object to the models (mandatory).\nscale::T: Scale of the object (optional, 0.0 as default).\ninclinationAzimut::T: Inclination azimut of the object (optional, 0.0 as default).\ninclinationAngle::T: Inclination angle of the object (optional, 0.0 as default).\nrotation::T: Rotation of the object (optional, 0.0 as default).\n\nDetails\n\nobject_table can be of any format that implement the Tables.jl interface, e.g. an array of NamedTuples, a DataFrame...\n\nExample\n\n```julia using Meshes using Tables using PlantGeom\n\nscenedimensions = (Meshes.Point(0.0, 0.0, 0.0), Meshes.Point(100.0, 100.0, 100.0)) positions = [Meshes.Point(50.0, 50.0, 50.0), Meshes.Point(60.0, 60.0, 60.0), Meshes.Point(70.0, 70.0, 70.0)] objecttable = [     (sceneID=1, plantID=p, filePath=\"opf/plantp.opf\", pos=positions[p], functionalgroup=\"plant\", rotation=0.1) for p in 1:3 ]\n\nwriteops(\"scene.ops\", scenedimensions, object_table)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.xmax","page":"API","title":"PlantGeom.xmax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.xmin","page":"API","title":"PlantGeom.xmin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.ymax","page":"API","title":"PlantGeom.ymax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.ymin","page":"API","title":"PlantGeom.ymin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.zmax","page":"API","title":"PlantGeom.zmax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.zmin","page":"API","title":"PlantGeom.zmin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#RecipesBase.plot","page":"API","title":"RecipesBase.plot","text":"plot(opf::MultiScaleTreeGraph.Node; kwargs...)\nplot!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree, paired with a Plots.jl backend.\n\nSee also diagram for the same plot with a Makie.jl backend.\n\nAttributes\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nExamples\n\n# import Pkg; Pkg.add(\"PlotlyJS\")\nusing Plots, PlantGeom\nplotlyjs()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\nplot(opf, node_color = :Length)\n\n\n\n\n\n","category":"function"},{"location":"API/#RecipesBase.plot!","page":"API","title":"RecipesBase.plot!","text":"plot(opf::MultiScaleTreeGraph.Node; kwargs...)\nplot!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree, paired with a Plots.jl backend.\n\nSee also diagram for the same plot with a Makie.jl backend.\n\nAttributes\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nExamples\n\n# import Pkg; Pkg.add(\"PlotlyJS\")\nusing Plots, PlantGeom\nplotlyjs()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\nplot(opf, node_color = :Length)\n\n\n\n\n\n","category":"function"}]
}
