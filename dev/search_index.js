var documenterSearchIndex = {"docs":
[{"location":"geometry/geometry/#Geometry-Concepts-in-PlantGeom","page":"Concepts","title":"Geometry Concepts in PlantGeom","text":"","category":"section"},{"location":"geometry/geometry/#Overview","page":"Concepts","title":"Overview","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"PlantGeom provides a framework for representing, manipulating, and visualizing 3D plant architecture. This page introduces the key concepts behind PlantGeom's approach to geometry handling.","category":"page"},{"location":"geometry/geometry/#Reference-Mesh-Design-Philosophy","page":"Concepts","title":"Reference Mesh Design Philosophy","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"Most plants contain many similar organs - think of hundreds of leaves on a tree that share the same basic shape but differ in size and orientation. PlantGeom leverages this biological pattern through its reference mesh approach:","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"Define a single reference mesh for each organ type (e.g., a generic leaf shape)\nApply transformations (scaling, rotation, translation) to position each instance","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"This approach offers significant benefits:","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"Memory efficiency: Store one mesh instead of hundreds of copies\nSmaller file sizes: OPF files store only unique reference meshes plus transformations\nPerformance: Operations can be applied to reference meshes once rather than to many instances","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"For highly specialized shapes that can't be derived from a reference (like wheat leaves with complex curvatures), PlantGeom can still use direct mesh representations.","category":"page"},{"location":"geometry/geometry/#Key-Components","page":"Concepts","title":"Key Components","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"PlantGeom's geometry system consists of three main components:","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"RefMesh: A reference mesh with a unique identifier and the mesh data\nGeometry: A container that links a RefMesh to a node and stores transformation information\nTransformations: Operations that scale, rotate, and position instances of reference meshes","category":"page"},{"location":"geometry/geometry/#MTG-Integration","page":"Concepts","title":"MTG Integration","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"Geometries in PlantGeom are attached to nodes in a Multi-scale Tree Graph (MTG) that represents plant topology:","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"# Attaching geometry to an MTG node\nnode.geometry = Geometry(ref_mesh=some_ref_mesh, transformation=some_transformation)","category":"page"},{"location":"geometry/geometry/#Documentation-Structure","page":"Concepts","title":"Documentation Structure","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"To learn more about PlantGeom's geometry features:","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"Reference Meshes: Learn how to create and work with reference meshes\nBuilding Plant Models: Step-by-step guide to constructing complete plant geometries\nMerging Meshes: Tools for combining geometries at different scales","category":"page"},{"location":"geometry/geometry/#File-Format-Support","page":"Concepts","title":"File Format Support","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"PlantGeom works with several file formats:","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"OPF: Open Plant Format - combines MTG structure and geometry efficiently\nOBJ/PLY/STL: Common 3D mesh formats","category":"page"},{"location":"geometry/geometry/#Basic-Usage-Example","page":"Concepts","title":"Basic Usage Example","text":"","category":"section"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"using PlantGeom\nusing CairoMakie\n\n# Load a plant model with geometry\nmtg = read_opf(\"path/to/plant.opf\")\n\n# Visualize\nfig = Figure()\nax = Axis3(fig[1, 1])\nplantviz!(ax, mtg)\nfig","category":"page"},{"location":"geometry/geometry/","page":"Concepts","title":"Concepts","text":"For more visualization options, see the 3D recipes section.","category":"page"},{"location":"geometry/building_plant_models/#Building-Plant-Models","page":"Building Plant Models","title":"Building Plant Models","text":"","category":"section"},{"location":"geometry/building_plant_models/#Overview","page":"Building Plant Models","title":"Overview","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"This guide explains how to build complete plant geometries by combining reference meshes with transformations and associating them with nodes in a MultiScaleTreeGraph (MTG) structure. PlantGeom makes it easy to create realistic 3D plant models by leveraging reference meshes for different organ types and applying appropriate transformations.","category":"page"},{"location":"geometry/building_plant_models/#Geometry-in-MTG-Nodes","page":"Building Plant Models","title":"Geometry in MTG Nodes","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"In PlantGeom, 3D geometries are attached to MTG nodes through the :geometry attribute. Each node's geometry is represented by a Geometry object, which typically contains:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"A reference to a RefMesh that defines the base shape\nA transformation that positions, scales, and orients the mesh","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"# The core Geometry type\nPlantGeom.Geometry(; \n    ref_mesh::RefMesh,                  # The reference mesh to use\n    transformation=Identity(),          # Transformation to apply to the reference mesh (here, no transformation)\n)","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"Geometry also has the dUp and dDwn arguments for appyling tapering to the geometry (i.e. make it pointy), but it is rarely used in practice, and is there for backward compatibility with the OPF file format. It also has the mesh field, which is used to store the mesh resulting from applying the transformation to the reference mesh. This one is lazily computed because we prefer not store it unless we really have to.","category":"page"},{"location":"geometry/building_plant_models/#Creating-Plant-Organ-Geometries","page":"Building Plant Models","title":"Creating Plant Organ Geometries","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"The typical workflow for building a plant geometry is:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"Create reference meshes for each organ type (e.g., stem, leaf, root)\nTraverse the MTG structure\nFor each node, create a Geometry with the appropriate reference mesh and transformation","category":"page"},{"location":"geometry/building_plant_models/#Step-1:-Create-Reference-Meshes","page":"Building Plant Models","title":"Step 1: Create Reference Meshes","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"First, define a reference mesh for each type of plant organ:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"using PlantGeom\nusing Meshes, Colors\n\n# Create a cylinder reference mesh for internodes and roots, oriented towards the z direction\ncylinder = Meshes.CylinderSurface(Meshes.Point(0.0, 0.0, 0.0), Meshes.Point(0.0, 0.0, 1.0), 0.5) |> \n           Meshes.discretize |> Meshes.simplexify\nrefmesh_cylinder = RefMesh(\"Cylinder\", cylinder, RGB(0.5, 0.5, 0.5))\n# RGB(0, 0.5, 0), RGB(0, 0.5, 0.1), RGB(0.1, 0.5, 0)]\n# Make a reference mesh for the leaves:\nw = l = 1 # Leaf width and length are set to 1.0 to facilitate transformations\np = 0.2 * l # Petiole length is set to 20% of the leaf length\npoints = [\n        (0.0, -0.05 * w, 0.0), # Petiole base 1\n        (0.0, 0.05 * w, 0.0), # Base 2. NB: the petiole base width is 5% of the leaf width \n        (p, 0.0, 0.0), # End of petiole, first point of leaf blade\n        (p + l, 0.0, 0.0), # tip of the leaf\n        (p + l / 2.0, -w / 2.0, 0.0),\n        (p + l / 2.0, w / 2.0, 0.0)\n    ]\n\nconnec = Meshes.connect.(\n    [\n        (1, 2, 3), # Petiole\n        (3, 5, 4), # left part of the leaf\n        (3, 6, 4)  # right part of the leaf\n    ],\n    Triangle\n)\n\nrefmesh_leaf = RefMesh(\"Leaf\", Meshes.SimpleMesh(points, connec), RGB(0.1, 0.5, 0))","category":"page"},{"location":"geometry/building_plant_models/#Step-2:-Make-a-plant-graph","page":"Building Plant Models","title":"Step 2: Make a plant graph","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"For this example, we'll create a very simple plant that has only one meristem going upward, producing one internode and one leaf per internode, and one root meristem going downward.","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"using MultiScaleTreeGraph\n\nfunction build_mtg(n_internode=5, n_roots = 3)\n    # Starting with the plant scale:\n    mtg = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\n\n    # Then, adding internodes and leaves recursively:\n    last_node = mtg\n    for i in 1:n_internode\n        internode = Node(last_node, NodeMTG(i == 1 ? \"/\" : \"<\", \"Internode\", i, 2))\n        Node(internode, NodeMTG(\"+\", \"Leaf\", i, 2)) # Branching with a leaf\n        last_node = internode\n    end\n\n    # And finally, adding the roots:\n    last_root = mtg\n    for i in 1:n_roots\n        last_root = Node(last_root, NodeMTG(i == 1 ? \"/\" : \"<\", \"RootSegment\", i, 2))\n    end\n\n    return mtg\nend\n\n# Now let's use our function to create a plant:\n\nmtg = build_mtg()","category":"page"},{"location":"geometry/building_plant_models/#Step-3:-Associate-Geometries-with-MTG-Nodes","page":"Building Plant Models","title":"Step 3: Associate Geometries with MTG Nodes","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"Next, traverse the MTG and assign the appropriate geometry to each node:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"using MultiScaleTreeGraph\nimport TransformsBase: → # The → operator from TransformsBase composes transformations\nusing Rotations\n\nfunction add_geometry!(mtg, refmesh_cylinder, refmesh_leaf)\n    # Track the current height for positioning internodes\n    current_height = 0.0\n    internode_width = 0.1\n    internode_length = 0.3\n    root_width = 0.05\n    root_length = 0.5\n    root_depth = -0.5  # Start below ground\n    phyllotaxy = 0.0\n\n    traverse!(mtg) do node\n        if symbol(node) == \"Internode\"\n            # Scale and position the internode\n            transformation = Meshes.Scale(internode_width, internode_width, internode_length) → \n            Meshes.Translate(0.0, 0.0, current_height)\n            \n            # Attach geometry to this node\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_cylinder, transformation=transformation)\n            \n            # Update the height for the next internode\n            current_height += internode_length\n            phyllotaxy += π/2\n\n        elseif symbol(node) == \"Leaf\"\n            # Scale, rotate, and position the leaf\n            leaf_length = 0.20 + 0.10*current_height\n            leaf_width = 0.5 * leaf_length\n            transformation = Meshes.Scale(leaf_length, leaf_width, 1e-6) → \n                             Meshes.Rotate(RotY(-π/4)) → # Give an insertion angle to the leaf\n                             Meshes.Translate(internode_width/2.0, 0.0, current_height) → # Position on the stem\n                             Meshes.Rotate(RotZ(phyllotaxy))                            \n            # Attach geometry to this node\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_leaf, transformation=transformation)\n        elseif symbol(node) == \"RootSegment\"\n            # Scale and position the root (going downward)            \n            transformation = Meshes.Scale(root_width, root_width, root_length) →\n                             Meshes.Translate(0.0, 0.0, root_depth) →\n                             Meshes.Rotate(RotZ(π))  # Point downward\n            \n            # Attach geometry to this node\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_cylinder,\n                                              transformation=transformation)\n            \n            # Update the depth for the next root segment\n            root_depth -= root_length\n        end\n    end\nend","category":"page"},{"location":"geometry/building_plant_models/#Step-4:-Visualize-the-Plant","page":"Building Plant Models","title":"Step 4: Visualize the Plant","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"We can build a plant and compute the geometry of each node using the previous two functions:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"mtg = build_mtg()\nadd_geometry!(mtg, refmesh_cylinder, refmesh_leaf)","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"And finally, we can visualize our plant:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"using PlantGeom, CairoMakie  # or GLMakie for interactive 3D, or WGLMakie for web\n\n# Visualize the plant\nfig = Figure()\nax = Axis3(fig[1, 1], aspect=:data)\nplantviz!(ax, mtg)\nfig","category":"page"},{"location":"geometry/building_plant_models/#Working-with-Direct-Meshes","page":"Building Plant Models","title":"Working with Direct Meshes","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"In some cases, you may want to use the transformed mesh directly rather than reference meshes. This is particularly useful for complex or unique organ shapes such as grass leaves. In this case, you can provide the mesh as a reference mesh:","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"# Direct mesh approach\ncomplex_leaf_mesh = load_mesh(\"complex_leaf.obj\")\n\n# During MTG traversal:\nnode.geometry = PlantGeom.Geometry(ref_mesh=complex_leaf_mesh)","category":"page"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"By default, Geometry uses the Identity transformation, which means no transformation.","category":"page"},{"location":"geometry/building_plant_models/#Tips-for-Building-Realistic-Plant-Geometries","page":"Building Plant Models","title":"Tips for Building Realistic Plant Geometries","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"Understand mesh orientation: Know the default orientation of your reference meshes to apply transformations correctly\nUse transformation composition: The → operator allows clean composition of multiple transformations\nScale appropriately: Make sure organ scales match realistically with each other\nPhyllotaxy patterns: Implement botanical phyllotaxy patterns (opposite, alternate, whorled, etc.)\nCalibrate transformations: You may need to experiment with transformation parameters to get realistic positioning","category":"page"},{"location":"geometry/building_plant_models/#Conclusion","page":"Building Plant Models","title":"Conclusion","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"By combining reference meshes with appropriate transformations, you can build complex and realistic 3D plant models efficiently. The use of reference meshes saves memory and computational resources while still allowing for detailed and visually appealing plant representations.","category":"page"},{"location":"geometry/building_plant_models/#More-examples","page":"Building Plant Models","title":"More examples","text":"","category":"section"},{"location":"geometry/building_plant_models/","page":"Building Plant Models","title":"Building Plant Models","text":"You can look at VPalm.jl to get an idea of a more complex 3D reconstruction of a plant using sequential architectural allometries.","category":"page"},{"location":"geometry/merging_geometry/#Merging-Fine-Scale-Geometry","page":"Merging Meshes","title":"Merging Fine-Scale Geometry","text":"","category":"section"},{"location":"geometry/merging_geometry/#Overview","page":"Merging Meshes","title":"Overview","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"Plant architecture is often represented at multiple scales - from fine details like individual leaflets to coarser representations like whole leaves or branches. While detailed structural representation is valuable, there are significant computational benefits to merging fine-scale geometries into coarser scales:","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"Computational efficiency: Processing a single merged mesh is faster than handling many small ones\nScale-appropriate analysis: When analysis is performed at a coarser scale (e.g., axis level), there's no need to maintain separate geometries for each component\nStreamlined visualization: Rendering performance improves significantly with fewer meshes","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"PlantGeom provides tools to merge fine-scale geometries into coarser representations while preserving the complete geometric detail.","category":"page"},{"location":"geometry/merging_geometry/#The-merge_children_geometry!-Function","page":"Merging Meshes","title":"The merge_children_geometry! Function","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"The merge_children_geometry! function allows you to merge geometries from lower-scale nodes into higher-scale parent nodes without losing geometric detail.","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"merge_children_geometry!(mtg; from, into, delete=:nodes, verbose=true, child_link_fun=x -> new_child_link(x, verbose))","category":"page"},{"location":"geometry/merging_geometry/#Parameters","page":"Merging Meshes","title":"Parameters","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"mtg: The MultiScaleTreeGraph to process.\nfrom: The type(s) of nodes whose geometry should be merged upward (lower scale). Can be a string or a vector of strings, e.g. [\"Metamer\", \"Leaf\"].\ninto: The type of nodes to merge into (higher scale). Must be a single string, e.g. \"Axis\".\ndelete: A symbol indicating what to do after merging:\n:none: Keep both the original nodes and their geometry.\n:geometry: Keep the original nodes but remove their geometry (saves memory).\n:nodes: Delete the original nodes entirely (requires a child_link_fun).\nverbose: A boolean indicating whether to print progress messages.\nchild_link_fun: A function that handles reconnecting children when nodes are deleted. The default function is new_child_link from the MultiScaleTreeGraph.jl package, which tries to be clever on relinking the children nodes.","category":"page"},{"location":"geometry/merging_geometry/#Example:-Merging-Coffee-Plant-Geometry","page":"Merging Meshes","title":"Example: Merging Coffee Plant Geometry","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"Let's walk through an example using a coffee plant model where we merge the geometry of metamers and leaves into their parent axis.","category":"page"},{"location":"geometry/merging_geometry/#Original-Plant-Model","page":"Merging Meshes","title":"Original Plant Model","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"First, let's look at the original coffee plant model with geometry at the metamer and leaf level:","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"using PlantGeom\nusing CairoMakie\n\n# Load the coffee plant model\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"coffee.opf\"))\n\n# Visualize the original model\nfig = Figure(size=(600, 600))\nax = Axis3(fig[1, 1], aspect=:data, title=\"Original Coffee Plant\")\nplantviz!(ax, mtg)\nhidedecorations!(ax)\nhidespines!(ax)\nfig","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"In this visualization, each metamer and leaf has its own individual mesh. This results in thousands of small meshes that need to be processed and rendered separately.","category":"page"},{"location":"geometry/merging_geometry/#Merging-Geometry-while-Keeping-Nodes","page":"Merging Meshes","title":"Merging Geometry while Keeping Nodes","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"We can merge the geometry from metamers and leaves up to the axis level while keeping the original node structure intact:","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"mtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"coffee.opf\"))\n\n# Create a copy to preserve the original\nmtg_merged1 = deepcopy(mtg)\n\n# Merge geometry from \"Metamer\" and \"Leaf\" into \"Axis\"\nmerge_children_geometry!(mtg_merged1; \n    from=[\"Metamer\", \"Leaf\"], \n    into=\"Axis\", \n    delete=:geometry, \n)\n\n# Visualize the result\nfig = Figure(size=(600, 600))\nax = Axis3(fig[1, 1], aspect=:data, title=\"Merged Geometry (Keeping Nodes)\")\nplantviz!(ax, mtg_merged1)\nhidedecorations!(ax)\nhidespines!(ax)\nfig","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"The plant looks identical, but the geometry is now stored at the axis level rather than at individual metamers and leaves. The original nodes still exist in the MTG structure, but their geometry properties have been removed to save memory.","category":"page"},{"location":"geometry/merging_geometry/#Merging-Geometry-and-Deleting-Nodes","page":"Merging Meshes","title":"Merging Geometry and Deleting Nodes","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"For even more streamlined representation, we can completely remove the lower-scale nodes:","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"mtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"coffee.opf\"))\n\n# Create a copy to preserve the original\nmtg_merged2 = deepcopy(mtg)\n\n# Merge geometry and delete the original nodes\nmerge_children_geometry!(mtg_merged2; \n    from=[\"Metamer\", \"Leaf\"], \n    into=\"Axis\", \n    delete=:nodes, \n)\n\n# Visualize the result\nfig = Figure(size=(600, 600))\nax = Axis3(fig[1, 1], aspect=:data, title=\"Merged Geometry (Nodes Deleted)\")\nplantviz!(ax, mtg_merged2)\nhidedecorations!(ax)\nhidespines!(ax)\nfig","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"The visual result is still the same, but now the MTG structure has been simplified by removing the metamer and leaf nodes entirely. The complete geometry is preserved at the axis level.","category":"page"},{"location":"geometry/merging_geometry/#Performance-Comparison","page":"Merging Meshes","title":"Performance Comparison","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"The performance improvements from merging geometry can be substantial:","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"using Statistics\n# Run benchmarks (would be better to use BenchmarkTools, but this is an approximation)\noriginal_time = @elapsed plantviz(mtg)\nmerged1_time = @elapsed plantviz(mtg_merged1)\nmerged2_time = @elapsed plantviz(mtg_merged2)\n\n# Display the table\ntable_fig = Figure(size=(600, 200))\nax = Axis(table_fig[1, 1], title=\"Rendering Time (ms)\", xticks = (1:3, [\"Original Model\", \"Merged (Keeping Nodes)\", \"Merged (Nodes Deleted)\"]))\nbarplot!(ax, 1:3, [original_time, merged1_time, merged2_time])\ntable_fig","category":"page"},{"location":"geometry/merging_geometry/#Use-Cases","page":"Merging Meshes","title":"Use Cases","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"Geometry merging is particularly useful for:","category":"page"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"Light interception calculations computed at the triangle level but integrated at axis scale\nLarge-scale simulations where computational efficiency is crucial\nVisualization of complex plants where rendering performance matters\nScale-appropriate modeling where geometry is needed at higher scales but not at fine scales","category":"page"},{"location":"geometry/merging_geometry/#Notes","page":"Merging Meshes","title":"Notes","text":"","category":"section"},{"location":"geometry/merging_geometry/","page":"Merging Meshes","title":"Merging Meshes","text":"Merging preserves all geometric detail but organizes it at a coarser scale\nThe MTG structure can be maintained (using delete=:geometry) or simplified (using delete=:nodes)\nWhen deleting nodes, make sure to provide an appropriate child_link_fun to maintain connectivity. The default function new_child_link tries to be smart, but it may not suit your specific use case.","category":"page"},{"location":"plot_diagram/makie_diagram/#Makie.jl-recipes","page":"Makie.jl","title":"Makie.jl recipes","text":"","category":"section"},{"location":"plot_diagram/makie_diagram/#Diagram","page":"Makie.jl","title":"Diagram","text":"","category":"section"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"We can make a diagram of the MTG graph using the diagram function:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"using PlantGeom, CairoMakie\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\ndiagram(opf)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"We can change the color of the nodes:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"diagram(opf, color = :palegreen1)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"The color argument is for the node color. The edges are colored with the same color than the nodes by default, but you can also use a different color if you want using edge_color:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"diagram(opf, color = :palegreen1, edge_color = :sienna)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"You can also color your nodes based on an attribute from the MTG, e.g. using the nodes Z coordinates:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"# First, we compute \"fake\" coordinates for each node in the MTG (just for ploting):\nPlantGeom.coordinates!(opf, force = true)\n# Then we plot the MTG using the newly created ZZ attribute:\ndiagram(opf, color = :YY)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"We can also color the edges differently, e.g. using the XX attribute computed using coordinates!:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"PlantGeom.coordinates!(opf, force = true)\ndiagram(opf, color = :YY, edge_color = :XX)","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"Attributes used for coloring may have missing values. In this case you can choose their color using color_missing, e.g.:","category":"page"},{"location":"plot_diagram/makie_diagram/","page":"Makie.jl","title":"Makie.jl","text":"diagram(opf, color = :Length, edge_color = :Width, color_missing = :red)","category":"page"},{"location":"geometry/refmesh/#RefMesh","page":"Reference Meshes","title":"RefMesh","text":"","category":"section"},{"location":"geometry/refmesh/#Overview","page":"Reference Meshes","title":"Overview","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"RefMesh is a core type in PlantGeom.jl that represents a reference mesh. It combines a mesh geometry with metadata such as an identifier, making it suitable for use in plant architecture models.","category":"page"},{"location":"geometry/refmesh/#Reference-Mesh-Concept","page":"Reference Meshes","title":"Reference Mesh Concept","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"PlantGeom implements an efficient approach to representing plant geometry based on the insight that most organs of the same type (e.g., leaves, internodes) share a common shape that varies only in size, orientation, and position. Instead of storing complete, unique mesh data for each organ instance, PlantGeom uses:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"A reference mesh that defines the canonical shape of the organ type\nTransformation matrices for each instance that scale, rotate, and translate this reference into the correct position","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"This method is especially powerful for plants like trees with thousands of similar leaves, where storing a unique mesh for each leaf would consume enormous amounts of memory.","category":"page"},{"location":"geometry/refmesh/#Benefits-of-the-Reference-Mesh-Approach","page":"Reference Meshes","title":"Benefits of the Reference Mesh Approach","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"Memory efficiency: Only one mesh is stored for many organs with the same shape\nSmaller file sizes: The OPF file format leverages this concept, storing only unique reference meshes plus transformation matrices\nComputational optimization: Operations can be applied to one mesh rather than thousands of individual copies","category":"page"},{"location":"geometry/refmesh/#Handling-Special-Cases","page":"Reference Meshes","title":"Handling Special Cases","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"For organs with unique shapes that cannot be easily derived from scaling and transforming a reference (such as wheat leaves with complex curvature angles), PlantGeom accommodates this by:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"Using the actual specific mesh as the reference mesh\nUsing an identity transformation matrix (no transformation)","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"This flexibility ensures that PlantGeom can represent both regular, repeating structures and unique, complex shapes within the same model.","category":"page"},{"location":"geometry/refmesh/#Structure","page":"Reference Meshes","title":"Structure","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"A RefMesh contains:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"id: A string identifier for the mesh\nmesh: The actual mesh data structure (typically a SimpleMesh from Meshes.jl)","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"warning: Warning\nThe RefMesh is usually oriented with its length along the X direction, its width along the Y direction, and its height along the Z direction. This orientation is important for ensuring that transformations and visualizations behave as expected. You can still orient the mesh in any direction, but you'll have to handle the transformations appropriately.","category":"page"},{"location":"geometry/refmesh/#Creating-a-RefMesh","page":"Reference Meshes","title":"Creating a RefMesh","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"There are several ways to create a RefMesh.","category":"page"},{"location":"geometry/refmesh/#From-an-Existing-Mesh","page":"Reference Meshes","title":"From an Existing Mesh","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"You can create a RefMesh from an existing mesh object. This is useful when you have a mesh already defined and want to wrap it in a RefMesh for use in PlantGeom:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"using PlantGeom\nusing GeoIO\n\n# Read a mesh from a file: \ngeotable = GeoIO.load(\"flower.ply\")\n# Create a RefMesh from an existing mesh:\nref_mesh = RefMesh(\"flower\", geotable.geometry)","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"You can find an example for the trunk snags in VPalm here.","category":"page"},{"location":"geometry/refmesh/#From-Vertices-and-Faces","page":"Reference Meshes","title":"From Vertices and Faces","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"You can manually create a mesh from vertices and faces first, and pass it to the RefMesh. This is useful for defining simple shapes or custom meshes.","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"For example we can creata a plane mesh with 4 vertices and 2 triangles:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"using Meshes\nmesh_vertices = [\n    Meshes.Point(0.0, 0.0, -0.5),  # Left bottom\n    Meshes.Point(1.0, 0.0, -0.5),   # Right bottom\n    Meshes.Point(1.0, 0.0, 0.5),   # Right top\n    Meshes.Point(0.0, 0.0, 0.5)   # Left top\n]\n\n# Create triangular faces\n# Two triangles to form the rectangle\nmesh_faces = [\n    Meshes.connect((1, 2, 3), Meshes.Triangle),\n    Meshes.connect((1, 3, 4), Meshes.Triangle)\n]\n\n# Create the mesh\nmesh = Meshes.SimpleMesh(mesh_vertices, mesh_faces)\n\nref_mesh = RefMesh(\"plane\", mesh)\n\nplantviz(ref_mesh)","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"This is used to create simple leaflets elements in VPalm.","category":"page"},{"location":"geometry/refmesh/#From-Primitive-Shapes","page":"Reference Meshes","title":"From Primitive Shapes","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"You can also create a RefMesh directly from primitive shapes like spheres, cylinders, or cones. This is useful for quickly generating common geometric forms. The only thing to remember is to use the discretize function to create a mesh from the primitive shape, and then use the simplexify function to convert it to a triangulated mesh.","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"To create a sphere:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"using Meshes\nsphere_mesh = Meshes.Sphere((0.0, 0.0, 0.0), 1.0) |> Meshes.discretize |> Meshes.simplexify\nsphere_refmesh = RefMesh(\"sphere_1\", sphere_mesh)\nplantviz(sphere_refmesh)","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"Or a cylinder:","category":"page"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"cyl = Meshes.CylinderSurface((0.0, 0.0, 0.0), (0.0, 0.0, 1.0), 0.5) |> Meshes.discretize |> Meshes.simplexify\ncylinder_refmesh = RefMesh(\"cylinder_1\", cyl)\n\nplantviz(cylinder_refmesh)","category":"page"},{"location":"geometry/refmesh/#Working-with-RefMesh","page":"Reference Meshes","title":"Working with RefMesh","text":"","category":"section"},{"location":"geometry/refmesh/#Accessing-Properties","page":"Reference Meshes","title":"Accessing Properties","text":"","category":"section"},{"location":"geometry/refmesh/","page":"Reference Meshes","title":"Reference Meshes","text":"# Get the ID\nname = cylinder_refmesh.name\n\n# Get the underlying reference mesh\nmesh = cylinder_refmesh.mesh\n\n# Or any other property of the mesh:\nfieldnames(typeof(cylinder_refmesh))\n\n# Get vertices\nverts = vertices(cylinder_refmesh.mesh)\n\n# Get faces\nfaces = Meshes.topology(cylinder_refmesh.mesh)","category":"page"},{"location":"architecture/#Architecture-Overview","page":"Architecture","title":"Architecture Overview","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"This package bridges Plant MTGs with meshes and visualization.","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"OPF/OPS files ──► read_opf/read_ops ──► MTG (MultiScaleTreeGraph)\n                                  │\n                                  ▼\n                         Reference Meshes (RefMesh)\n                                  │\n                                  ▼\n              Geometry (ref_mesh + transform + cached mesh)\n                                  │\n                   refmesh_to_mesh! / transform_mesh!\n                                  │\n                                  ▼\n                        Meshes.SimpleMesh geometry\n                                  │\n                                  ▼\n            plantviz (Makie recipe) ──► Makie Figure/Axis","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Core types: RefMesh stores template geometry; Geometry attaches a ref_mesh, a transform (Translate, Rotate, Scale, Affine, or SequentialTransform), and an optional cached mesh to an MTG node attribute :geometry.\nIO: read_opf/read_ops populate MTG nodes and scene transforms; write_opf/write_ops serialize meshes and transforms back to disk.\nComputation: meshes are computed lazily; call refmesh_to_mesh! to materialize or transform_mesh! to apply composed transforms. Matrix generation uses get_transformation_matrix.\nVisualization: plantviz dispatches to Makie recipes in ext/makie_recipes/, mapping colors from attributes or user dictionaries via get_color/get_colormap.","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Minimal example","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"using PlantGeom\nopf = read_opf(\"test/files/simple_plant.opf\")\nrefmesh_to_mesh!(opf)              # materialize per-node meshes\nfig, ax, plt = plantviz(opf)       # visualize","category":"page"},{"location":"plot_diagram/plots_diagram/#Plots.jl-recipes","page":"Plots.jl","title":"Plots.jl recipes","text":"","category":"section"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"PlantGeom.jl provides recipes to make plots using Plots.jl. The only recipe so far is to make a diagram of the MTG tree. This is especially useful to control the integrity of and MTG (where it branches, where are the different scales...).","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"To use this recipe, simply use Plots.jl and any backend, though we recommend PlotlyJS to make the plot interactive.","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"The plot recipe provides some arguments to customize the plot:","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"mode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"using Plots\n# import Pkg; Pkg.add(\"PlotlyJS\")\nplotlyjs()\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\nplot(opf, node_color = :Length)\nsavefig(\"mtgplot.html\"); nothing # hide","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"<object type=\"text/html\" data=\"mtgplot.html\" style=\"width:100%;height:500px;\"></object>","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"The default plot is a 2D projection of the MTG, but you can also get a 3D projection using the mode keyword argument:","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"plot(opf, node_color = :Length, mode = \"3d\")\nsavefig(\"mtgplot3d.html\"); nothing # hide","category":"page"},{"location":"plot_diagram/plots_diagram/","page":"Plots.jl","title":"Plots.jl","text":"<object type=\"text/html\" data=\"mtgplot3d.html\" style=\"width:100%;height:500px;\"></object>","category":"page"},{"location":"makie_3d/#3D-plots-(meshes)","page":"3D recipes","title":"3D plots (meshes)","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"PlantGeom uses Makie.jl to make 3d mesh plots. It also uses MeshViz.jl that is also based on Makie.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"This way the plots you make using PlantGeom support all the nice possibilities offered by Makie, such as making sub-plots, interactive plots...","category":"page"},{"location":"makie_3d/#Interactive-plot","page":"3D recipes","title":"Interactive plot","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Here comes the fun part! We can make 3D representations of the plants based on the geometry of each of its nodes.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"If you read your MTG from an OPF file, the 3D geometry should already be computed, so you just have to plantviz() the MTG.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Because we're plotting the interactive plot in the webpage, we must use Bonito first (no need when using Julia from the REPL or VS Code):","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"using Bonito\nPage()","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Then we can plot our interactive 3D plant:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"using PlantGeom, WGLMakie\nWGLMakie.activate!() # hide\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\nplantviz(mtg)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"warning: Warning\nThe plot may take some time to appear on your screen.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Note that the plot is interactive. This is because we use WGLMakie as a plotting backend. You can also use GLMakie for better performance, or CairoMakie if you want a fast, non-interactive plot.","category":"page"},{"location":"makie_3d/#Colors","page":"3D recipes","title":"Colors","text":"","category":"section"},{"location":"makie_3d/#Note-about-the-backend","page":"3D recipes","title":"Note about the backend","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"In this section, we will use the coffee plant provided as an example OPF file from the package. This one is more realistic than the tiny plant shown above. But because it is bigger, we will only provide static images instead of interactive plots. If you want to plot the interactive plots, you can execute the example code from below using GLMakie or WGLMakie instead of CairoMakie simply by replacing:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"using CairoMakie","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"By:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"using GLMakie","category":"page"},{"location":"makie_3d/#Set-up","page":"3D recipes","title":"Set-up","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"The first step is to compute the node meshes using the reference meshes and the transformation matrices. This is done very easily by mapping refmesh_to_mesh! to each node of the MTG like so:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"using MultiScaleTreeGraph\ntransform!(mtg, refmesh_to_mesh!)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"note: Note\nThis step is optional, and not needed if only few plots are performed because it is done automatically when plotting an MTG, but the results are discarded afterward to avoid too much memory usage. If you plant to make many plots, we advise to do this step to avoid to wait a long time each time.","category":"page"},{"location":"makie_3d/#Default-colors","page":"3D recipes","title":"Default colors","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"The default behavior of plantviz(mtg) -without providing colors- is to use the color of each reference mesh as the color of the corresponding node mesh. In other words, a leaf in a tree will be colored with the same color as the reference mesh used to represent it. This reference mesh is available as an attribute in the root node of the MTG. We can extract those reference meshes like so:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"using PlantGeom, CairoMakie\nCairoMakie.activate!()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\nmtg = read_opf(file)\n\nref_meshes = get_ref_meshes(mtg)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Then we can plot them in sequence:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"plantviz(ref_meshes)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Here we are looking at the reference meshes used to build the plant. Those meshes are then transformed by transformation matrices from each node to make the mesh of that node. So by default the color used for the nodes will be taken from these reference meshes.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"If we plot the coffee plant without providing any color, we would get:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"plantviz(mtg)","category":"page"},{"location":"makie_3d/#Single-color","page":"3D recipes","title":"Single color","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Now we can change the color of all meshes by providing a single color:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"plantviz(mtg, color = :gray87)","category":"page"},{"location":"makie_3d/#Map-color-to-reference-meshes","page":"3D recipes","title":"Map color to reference meshes","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"We can also associate a new color to each reference mesh.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"We can get the default color of each reference mesh by using:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"get_ref_meshes_color(ref_meshes)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Now we know there are two reference meshes, one for a cylinder called \"Mesh0\" colored in brown, and a second one for the leaf that is green.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"To update their colors we can simply pass the new colors as a dictionary mapping colors to the names of the reference meshes like so:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"plantviz(mtg, color = Dict(\"Mesh0\" => :gray87, \"Mesh1\" => \"#42A25ABD\"))","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"If we want to update the second reference mesh only (the leaves), we would do:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"plantviz(mtg, color = Dict(\"Mesh1\" => \"#42A25ABD\"))","category":"page"},{"location":"makie_3d/#Map-color-to-attributes","page":"3D recipes","title":"Map color to attributes","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Maybe the most interesting coloring option is to color by attribute.","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Indeed, each node in the MTG can have specific attributes, e.g. an area, a temperature...","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"You can see which attributes are available in an MTG using:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"print(names(mtg))","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"We can see that we have an attribute called :Area. Let's color each organ by its area:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"plantviz(mtg, color = :Area)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Of course all Makie commands are available. For example we can zoom-in the plot using scale!, and add a colorbar:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"f, ax, p = plantviz(mtg, color = :Area)\nCairoMakie.scale!(p, 1.5, 1.5, 1.5) # we zoom-in a little bit\nCairoMakie.Colorbar(f[1,2], label = \"Area\")\nf","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"We can see that the colorbar is only in relative values (0-1). If you need absolute values, you can use PlantGeom's colorbar instead:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"f, ax, p = plantviz(mtg, color = :Area)\ncolorbar(f[1, 2], p)\nf","category":"page"},{"location":"makie_3d/#Map-color-to-vertices","page":"3D recipes","title":"Map color to vertices","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"# Compute the z position of each vertices in each mesh:\ntransform!(mtg, :geometry => (x -> [Meshes.coords(i).z for i in Meshes.vertices(x.mesh)]) => :z, ignore_nothing = true)\nplantviz(mtg, color = :z, showfacets = true)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"note: Note\nThis one is not shown because CairoMakie and WGLMakie are not compatible with coloring each vertices differently. But you can still see the results on your computer using GLMakie.","category":"page"},{"location":"makie_3d/#Map-time-step-to-color","page":"3D recipes","title":"Map time step to color","text":"","category":"section"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"The MTG attributes can have several values, for example a value for each time step of a simulation. For example, let's make a dummy variable with 12 time-steps, each value being the area time the time step:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"transform!(mtg, :Area => (x -> [x*i for i in 1:12]) => :dummy_var, ignore_nothing = true)","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"Now we can plot the plant with the color of each organ being the value of the dummy variable at time step 1 using the index keyword argument:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"f, ax, p = plantviz(mtg, color = :dummy_var, index = 1)\ncolorbar(f[1, 2], p)\nf","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"We can even make a video out of it:","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"f, ax, p = plantviz(mtg, color = :dummy_var, index = 1)\ncolorbar(f[1, 2], p)\n\nrecord(f, \"coffee_steps.mp4\", 1:12, framerate=2) do timestep\n    p.index[] = timestep\nend","category":"page"},{"location":"makie_3d/","page":"3D recipes","title":"3D recipes","text":"(Image: )","category":"page"},{"location":"#PlantGeom","page":"Home","title":"PlantGeom","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PlantGeom, a package about everything 3D-related for plants.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed around MultiScaleTreeGraph for the basic structure of plants (or any 3D object) topology and attributes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package provides different functionalities, the main ones being:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IO for the OPF file format (see read_opf and write_opf);\nplotting using plantviz and plantviz!, optionally using coloring by attribute;\nmesh transformations using transform_mesh!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that PlantGeom reserves the :geometry attribute in the nodes (e.g. organs). It uses it to store the 3D geometry as a special structure (Geometry).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to reproduce the animation, you can look at the code below. Otherwise, please head to the next section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie, Meshes, PlantGeom, MultiScaleTreeGraph\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\n\n# First, we compute the 3D coordinates for each node in the MTG:\ntransform!(opf, refmesh_to_mesh!)\n# And compute the max z of each node based on their mesh:\ntransform!(opf, zmax => :z_node, ignore_nothing = true)\n# Or the z coordinate of each vertex of each node mesh:\ntransform!(opf, :geometry => (x -> [Meshes.coords(i)z for i in Meshes.vertices(x.mesh)]) => :z_vertex, ignore_nothing = true)\n\n\n# Then we make a Makie figure:\nf = Figure()\nga = f[1, 1]\ngb = f[1, 2]\n\nax1 = Axis(ga[1, 1])\nax2 = Axis3(gb[1, 1], aspect = :data, title = \"3D representation (mesh)\", elevation = 0.15π, azimuth = 0.3π)\nhidedecorations!(ax2)\n\n# We can make a diagram out of the MTG, and coloring using the z coordinates attribute:\ndiagram!(ax1, opf, color = :z_node)\nhidedecorations!(ax1)\nax1.title = \"MultiscaleTreeGraph diagram\"\n\n# And a 3d representation:\n\nplantviz!(opf, color = :z_vertex)\n\n# And making a little animation out of it:\nCairoMakie.record(f, \"plant_animation.mp4\", 1:120) do frame\n    ax2.azimuth[] = 0.3π + 0.3 * sin(2π * frame / 120)\nend","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#PlantGeom.Geometry","page":"API","title":"PlantGeom.Geometry","text":"Geometry(; ref_mesh<:RefMesh, transformation=Identity(), dUp=1.0, dDwn=1.0, mesh::Union{SimpleMesh,Nothing}=nothing)\n\nA Node geometry with the reference mesh, its transformation (as a function) and the resulting mesh (optional, may be lazily computed).\n\nThe transformation field should be a TransformsBase.Transform, such as TransformsBase.Identity, or the ones implemented in  Meshes.jl, e.g. Translate, Scale... If you already have the transformation matrix, you can pass it to Meshes.Affine(). \n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.Material","page":"API","title":"PlantGeom.Material","text":"A material for the illumination model (e.g. Phong illumination).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.Phong","page":"API","title":"PlantGeom.Phong","text":"Data structure for a mesh material that is used to describe the light components of a Phong reflection type model. All data is stored as RGBα for Red, Green, Blue and transparency.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.PlantViz","page":"API","title":"PlantGeom.PlantViz","text":"PlantViz is the plot type associated with plotting function plantviz. Check the docstring for plantviz for further information.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.RefMesh","page":"API","title":"PlantGeom.RefMesh","text":"RefMesh(\n    name::S\n    mesh::SimpleMesh\n    normals::N\n    texture_coords::T\n    material::M\n    taper::Bool\n)\n\nRefMesh(name, mesh, material = RGB(220 / 255, 220 / 255, 220 / 255))\n\nRefMesh type. Stores all information about a Mesh:\n\nname::S: the mesh name\nmesh::SimpleMesh: the actual mesh information -> points and topology\nnormals::Vector{Float64}: the normals, given as a vector of x1,y1,z1,x2,y2,z2...\ntexture_coords::Vector{Float64}: the texture coordinates (not used yet), idem, a vector\nmaterial::M: the material, used to set the shading\ntaper::Bool: true if tapering is enabled\n\nThe reference meshes are then transformed on each node of the MTG using a transformation matrix to match the actual mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:PlantGeom.Geometry","page":"API","title":"Base.:==","text":"==(a::Geometry, b::Geometry)\n\nTest RefMesh equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:RefMesh","page":"API","title":"Base.:==","text":"==(a::RefMesh, b::RefMesh)\n\nTest RefMesh equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nelements-Tuple{RefMesh}","page":"API","title":"Meshes.nelements","text":"nelements(meshes::RefMesh)\n\nReturn the number of elements of a reference mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nvertices-Tuple{RefMesh}","page":"API","title":"Meshes.nvertices","text":"nvertices(meshes::RefMesh)\n\nReturn the number of vertices of a reference mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.viz","page":"API","title":"Meshes.viz","text":"viz(opf::MultiScaleTreeGraph.Node; kwargs...)\nviz!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nVizualise the 3D geometry of an MTG (usually read from an OPF). This function search for the :geometry attribute in each node of the MTG, and build the vizualisation using the mesh field, or the reference meshes and the associated transformation matrix if missing.\n\nThe :geometry attribute is usually added by the refmesh_to_mesh! function first, which can be called with the transform! function. See the examples below.\n\nArguments\n\nopf: The MTG to be vizualised.\nkwargs: Additional arguments to be passed to viz!, wich includes: \ncolor: The color to be used for the plot. Can be a colorant, an attribute of the MTG (given as a Symbol), or a dictionary of colors for each reference mesh.\ncolormap: The colorscheme to be used for the plot. Can be a Symbol or a ColorScheme. \nsegmentcolor: The color to be used for the facets. Should be a colorant or a symbol of color.\nshowsegments: A boolean indicating whether the facets should be shown or not.\ncolor_missing=RGBA(0, 0, 0, 0.3): The color to be used for missing values. Should be a colorant or a symbol of color.\nindex: An integer giving the index of the attribute value to be vizualised. This is useful when the attribute is a vector of values for e.g. each timestep.\ncolor_cache_name: The name of the color cache. Should be a string (default to a random string).\nfilter_fun: A function to filter the nodes to be plotted. Should be a function taking a node as argument and returning a boolean.\nsymbol: Plot only nodes with this symbol. Should be a String or a vector of.\nscale: Plot only nodes with this scale. Should be an Int or a vector of.\nlink: Plot only nodes with this link. Should be a String or a vector of.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, GLMakie\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\nviz(opf)\n\n# If you need to plot the opf several times, you better cache the mesh in the node geometry\n# like so:\ntransform!(opf, refmesh_to_mesh!)\n\n# Then plot it again like before, and it will be faster:\nviz(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\nviz(opf, color = :red)\n# One color per reference mesh:\nviz(opf, color = Dict(1 => :burlywood4, 2 => :springgreen4, 3 => :burlywood4))\n\n# Or just changing the color of some:\nviz(opf, color = Dict(1 => :burlywood4))\n\n# Or coloring by opf attribute, e.g. using the mesh max Z coordinates (NB: need to use\n# `refmesh_to_mesh!` before, see above):\ntransform!(opf, zmax => :z_max, ignore_nothing = true)\nviz(opf, color = :z_max)\n\n# One color for each vertex of the refmesh 1:\nusing Meshes\nvertex_color = get_color(1:nvertices(get_ref_meshes(opf))[1], [1,nvertices(get_ref_meshes(opf))[1]])\nviz(opf, color = Dict(1 => vertex_color))\n\n# Or even coloring by the value of the Z coordinates of each vertex:\ntransform!(opf, :geometry => (x -> [Meshes.coords(i).z for i in Meshes.vertices(x.mesh)]) => :z, ignore_nothing = true)\nviz(opf, color = :z, showsegments = true)\n\nf,a,p = viz(opf, color = :z, showsegments = true)\np[:color] = :Length\n\nviz!(ref_meshes; kwargs...)\n\nPlot all reference meshes in a single 3d plot using Makie.\n\nExamples\n\nusing PlantGeom, GLMakie\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\n\nviz(meshes)\n# With one shared color:\nviz(meshes, color = :green)\n# One color per reference mesh:\nviz(meshes, color = Dict(1 => :burlywood4, 2 => :springgreen4, 3 => :burlywood4))\n# Or just changing the color of some:\nviz(meshes, color = Dict(1 => :burlywood4, 3 => :burlywood4))\n# One color for each vertex of the refmesh 0:\nviz(meshes, color = Dict(2 => 1:nvertices(meshes)[2]))\n\n\n\n\n\n","category":"function"},{"location":"API/#Meshes.viz!","page":"API","title":"Meshes.viz!","text":"viz(opf::MultiScaleTreeGraph.Node; kwargs...)\nviz!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nVizualise the 3D geometry of an MTG (usually read from an OPF). This function search for the :geometry attribute in each node of the MTG, and build the vizualisation using the mesh field, or the reference meshes and the associated transformation matrix if missing.\n\nThe :geometry attribute is usually added by the refmesh_to_mesh! function first, which can be called with the transform! function. See the examples below.\n\nArguments\n\nopf: The MTG to be vizualised.\nkwargs: Additional arguments to be passed to viz!, wich includes: \ncolor: The color to be used for the plot. Can be a colorant, an attribute of the MTG (given as a Symbol), or a dictionary of colors for each reference mesh.\ncolormap: The colorscheme to be used for the plot. Can be a Symbol or a ColorScheme. \nsegmentcolor: The color to be used for the facets. Should be a colorant or a symbol of color.\nshowsegments: A boolean indicating whether the facets should be shown or not.\ncolor_missing=RGBA(0, 0, 0, 0.3): The color to be used for missing values. Should be a colorant or a symbol of color.\nindex: An integer giving the index of the attribute value to be vizualised. This is useful when the attribute is a vector of values for e.g. each timestep.\ncolor_cache_name: The name of the color cache. Should be a string (default to a random string).\nfilter_fun: A function to filter the nodes to be plotted. Should be a function taking a node as argument and returning a boolean.\nsymbol: Plot only nodes with this symbol. Should be a String or a vector of.\nscale: Plot only nodes with this scale. Should be an Int or a vector of.\nlink: Plot only nodes with this link. Should be a String or a vector of.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, GLMakie\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\nviz(opf)\n\n# If you need to plot the opf several times, you better cache the mesh in the node geometry\n# like so:\ntransform!(opf, refmesh_to_mesh!)\n\n# Then plot it again like before, and it will be faster:\nviz(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\nviz(opf, color = :red)\n# One color per reference mesh:\nviz(opf, color = Dict(1 => :burlywood4, 2 => :springgreen4, 3 => :burlywood4))\n\n# Or just changing the color of some:\nviz(opf, color = Dict(1 => :burlywood4))\n\n# Or coloring by opf attribute, e.g. using the mesh max Z coordinates (NB: need to use\n# `refmesh_to_mesh!` before, see above):\ntransform!(opf, zmax => :z_max, ignore_nothing = true)\nviz(opf, color = :z_max)\n\n# One color for each vertex of the refmesh 1:\nusing Meshes\nvertex_color = get_color(1:nvertices(get_ref_meshes(opf))[1], [1,nvertices(get_ref_meshes(opf))[1]])\nviz(opf, color = Dict(1 => vertex_color))\n\n# Or even coloring by the value of the Z coordinates of each vertex:\ntransform!(opf, :geometry => (x -> [Meshes.coords(i).z for i in Meshes.vertices(x.mesh)]) => :z, ignore_nothing = true)\nviz(opf, color = :z, showsegments = true)\n\nf,a,p = viz(opf, color = :z, showsegments = true)\np[:color] = :Length\n\nviz!(ref_meshes; kwargs...)\n\nPlot all reference meshes in a single 3d plot using Makie.\n\nExamples\n\nusing PlantGeom, GLMakie\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\n\nviz(meshes)\n# With one shared color:\nviz(meshes, color = :green)\n# One color per reference mesh:\nviz(meshes, color = Dict(1 => :burlywood4, 2 => :springgreen4, 3 => :burlywood4))\n# Or just changing the color of some:\nviz(meshes, color = Dict(1 => :burlywood4, 3 => :burlywood4))\n# One color for each vertex of the refmesh 0:\nviz(meshes, color = Dict(2 => 1:nvertices(meshes)[2]))\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.align_ref_meshes-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RefMesh","page":"API","title":"PlantGeom.align_ref_meshes","text":"align_ref_meshes(meshes::Vector{<:RefMesh})\n\nAlign all reference meshes along the X axis. Used for visualisation only.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.attributes_to_xml-NTuple{4, Any}","page":"API","title":"PlantGeom.attributes_to_xml","text":"attributes_to_xml(node, xml_parent)\n\nWrite an MTG node into an XML node.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.color_type-Union{Tuple{T}, Tuple{T, Any}} where T<:Symbol","page":"API","title":"PlantGeom.color_type","text":"color_type(color, opf)\n\nReturn the type of the color, whether it is an attribute, a colorant, or a RefMeshColorant.\n\nArguments\n\ncolor: The color to be checked.\nopf: The MTG to be plotted.\n\nReturns\n\nRefMeshColorant: If the color is :slategray3, then it is the default color given by Meshes,\n\nso we assume nothing was passed by the user and color by reference mesh instead.\n\nAttributeColorant: If the color is an attribute of the MTG, then we color by that attribute.\nT: If the color is a colorant, then we color everything by that color.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, Colors\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n\nopf = read_opf(file)\n\n# Colors:\ncolor_type(:red, opf)\ncolor_type(RGB(0.1,0.5,0.1), opf)\n\n# Attributes:\ncolor_type(:Length, opf)\n\n# Default color:\ncolor_type(:slategray3, opf)\n\n# Dict of colors:\ncolor_type(Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.5,0.1,0.1)), opf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.colorant_to_string-Tuple{T} where T<:ColorTypes.RGBA","page":"API","title":"PlantGeom.colorant_to_string","text":"colorant_to_string(x)\n\nParse a geometry material for OPF writing.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.colorbar-Tuple{Any, Any}","page":"API","title":"PlantGeom.colorbar","text":"colorbar(parent, plotobject, kwargs...)\n\nAdd a colorbar based on the attribute chose to color the plot. plotobject must be a plot of an MTG colored by an attribute. Use Makie.Colorbar for any other use case instead.\n\nArguments\n\nparent: parent scene\nplotobject: plot object to add the colorbar to\nkwargs: keyword arguments to pass to Makie.Colorbar, e.g. label=\"Length (m)\"\n\nExample\n\n```julia using GLMakie, MultiScaleTreeGraph, PlantGeom file = joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"simpleplant.opf\") opf = readopf(file)\n\nf, ax, p = plantviz(opf, color=:Length) colorbar(f[1, 2], p) f\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.coordinates!-Tuple{Any}","page":"API","title":"PlantGeom.coordinates!","text":"coordinates!(mtg; angle = 45; force = false)\n\nCompute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.\n\nReturns\n\nNothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncoordinates!(mtg)\nDataFrame(mtg, [:XX, :YY, :ZZ])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.diagram","page":"API","title":"PlantGeom.diagram","text":"diagram(opf::MultiScaleTreeGraph.Node; kwargs...)\ndiagram!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree using a Makie.jl backend.\n\ndanger: Danger\nThis function is an extension to the package. It is only available if you imported a Makie backend (e.g. using GLMakie) prior to using PlantGeom.\n\nThe main attributes are:\n\ncolor: the color of the nodes\ncolormap: the colormap used if the color uses an attribute. By default it uses viridis.\n\nMust be a ColorScheme from ColorSchemes or a Symbol with its name.\n\nExamples\n\nusing GLMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\ndiagram(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\ndiagram(opf, color = :red)\n\n# Or colouring by opf attribute, *e.g.* using the nodes Z coordinates:\ndiagram(opf, color = :ZZ)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.diagram!","page":"API","title":"PlantGeom.diagram!","text":"diagram(opf::MultiScaleTreeGraph.Node; kwargs...)\ndiagram!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree using a Makie.jl backend.\n\ndanger: Danger\nThis function is an extension to the package. It is only available if you imported a Makie backend (e.g. using GLMakie) prior to using PlantGeom.\n\nThe main attributes are:\n\ncolor: the color of the nodes\ncolormap: the colormap used if the color uses an attribute. By default it uses viridis.\n\nMust be a ColorScheme from ColorSchemes or a Symbol with its name.\n\nExamples\n\nusing GLMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\ndiagram(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\ndiagram(opf, color = :red)\n\n# Or colouring by opf attribute, *e.g.* using the nodes Z coordinates:\ndiagram(opf, color = :ZZ)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.extend_pos-NTuple{5, Any}","page":"API","title":"PlantGeom.extend_pos","text":"Add a new point after (x1,y1) using same direction and length relative to it\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_attr_type-Tuple{Any}","page":"API","title":"PlantGeom.get_attr_type","text":"Get the attributes types in Julia DataType.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_color-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Nothing}} where T<:AbstractArray","page":"API","title":"PlantGeom.get_color","text":"get_color(var <: AbstractArray, range_var, colormap=colorschemes[:viridis])\nget_color(var, range_var, colormap=colorschemes[:viridis])\n\nMap value(s) to colors from a colormap based on a range of values\n\nArguments\n\nvar: value(s) to map to colors\nrange_var: range of values to map to colors\ncolormap: colormap to use\n\nReturns\n\ncolor: color(s) corresponding to var\n\nExamples\n\n```julia using Colors\n\ngetcolor(1, 1:2, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415) getcolor(1:2, 1:10, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415) get_color(1:2, 1:10, 1, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_color_range-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.get_color_range","text":"get_color_range(colorrange, opf, colorant)\n\nGet the color range from the colorrange argument or from the MTG attribute.\n\nArguments\n\ncolorrange: the color range specified by the user, can be an Observable or a tuple of two values.\nopf: the MTG object.\ncolorant: the color attribute to use for the range.\n\nReturns\n\ncolorrange: the color range as a tuple of two values.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_colormap-Tuple{Any}","page":"API","title":"PlantGeom.get_colormap","text":"get_colormap(colormap)\n\nGet the colormap as a ColorScheme if it is a named color or ColorScheme\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_mtg_color-Tuple{Any, Any}","page":"API","title":"PlantGeom.get_mtg_color","text":"get_mtg_color(color, opf)\n\nReturn the color to be used for the plot.\n\nArguments\n\ncolor: The color to be checked.\nopf: The MTG to be plotted.\n\nReturns\n\nThe color to be used for the plot.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, Colors\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nget_mtg_color(:red, opf)\nget_mtg_color(RGB(0.1,0.5,0.1), opf)\nget_mtg_color(:Length, opf)\nget_mtg_color(:slategray3, opf)\nget_mtg_color(Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.1,0.1,0.5)), opf)\nget_mtg_color(Dict(1 => :burlywood4, 2 => :springgreen4), opf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_mesh_name-Tuple{Any}","page":"API","title":"PlantGeom.get_ref_mesh_name","text":"get_ref_mesh_name(node)\n\nGet the name of the reference mesh used for the current node.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_meshes-Tuple{Any}","page":"API","title":"PlantGeom.get_ref_meshes","text":"get_ref_meshes(mtg)\n\nGet all reference meshes from an mtg, usually from an OPF.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\n\nusing GLMakie\nplantviz(meshes)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_meshes_color-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RefMesh","page":"API","title":"PlantGeom.get_ref_meshes_color","text":"get_ref_meshes_color(meshes::Vector{<:RefMesh})\n\nGet the reference meshes colors (only the diffuse part for now).\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\nPlantGeom.get_ref_meshes_color(meshes)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.map_coord-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.map_coord","text":"map_coord(f, mesh, coord)\n\nApply function f over the mesh coordinates coord. Values for coord can be 1 for x, 2 for y and 3 for z.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.materialBDD_to_material-Tuple{Any}","page":"API","title":"PlantGeom.materialBDD_to_material","text":"Parse a material in opf format to a Phong material.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.material_to_opf_string-Tuple{Phong}","page":"API","title":"PlantGeom.material_to_opf_string","text":"material_to_opf_string(material::Phong)\nmaterial_to_opf_string(material::Colorant)\n\nFormat a material into a Dict for OPF writting.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.merge_children_geometry!-Tuple{Any}","page":"API","title":"PlantGeom.merge_children_geometry!","text":"merge_children_geometry!(mtg; from, into, delete=:nodes, verbose=true, child_link_fun=x -> new_child_link(x, verbose))\n\nSimplifies the geometry of a MultiScaleTreeGraph (MTG) by merging low-scale geometries into an higher-scale geometry.\n\nArguments\n\nmtg: The MultiScaleTreeGraph to process.\nfrom: The string for the type of nodes to simplify, this is the lower scale meshes that need to be merged. Can be a string or a vector of strings, e.g. [\"Petiole\", \"Rachis\"].\ninto: The string for the type of nodes to merge into. Must be a single string, e.g. \"Leaf\".\ndelete: A symbol indicating whether to delete the nodes or the geometry after merging:\n:none: No deletion will be performed, the geometry is merged into the into nodes, and also kept as before in the from nodes.\n:nodes: The nodes of type from will be deleted after merging.\n:geometry: Only the geometry will be deleted, but the from nodes will remain in the MTG.\nverbose: A boolean indicating if information should be returned when nodes or geometry was not found on expected nodes\nchild_link_fun: A function that takes a parent node targeted for deletion and returns the new links for their children. Required if delete is true. The\n\ndefault function is new_child_link, which tries to be clever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the link function instead.\n\nReturns\n\nNothing. The function modifies the mtg in place.\n\nNotes\n\nIf no geometry is found in the children nodes of type from, an informational message is logged.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.meshBDD_to_meshes-Tuple{Any}","page":"API","title":"PlantGeom.meshBDD_to_meshes","text":"meshBDD_to_meshes(x)\n\nExamples\n\nusing MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshBDD_to_meshes(opf[:meshBDD])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.mtg_coordinates_df","page":"API","title":"PlantGeom.mtg_coordinates_df","text":"mtg_coordinates_df(mtg, attr; force = false)\nmtg_coordinates_df!(mtg, attr; force = false)\n\nExtract the coordinates of the nodes of the mtg and the coordinates of their parents (:XXfrom, :YYfrom, :ZZ_from) and output a DataFrame. Optionally you can also provide an attribute to add to the output DataFrame too by passing its name as a symbol to attr.\n\nThe coordinates are computed using coordinates! if missing, or if force = true.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.mtg_to_opf_link-Tuple{Any}","page":"API","title":"PlantGeom.mtg_to_opf_link","text":"mtg_to_opf_link(link)\n\nTakes an MTG link as input (\"/\", \"<\" or \"+\") and outputs its corresponding link as declared in the OPF format (\"decomp\", \"follow\" or \"branch\")\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.mtg_topology_to_xml!","page":"API","title":"PlantGeom.mtg_topology_to_xml!","text":"mtg_topology_to_xml!(node, xml_parent)\n\nWrite the MTG topology, attributes and geometry into XML format. This function is used to write the \"topology\" section of the OPF.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.normals_vertex-Tuple{RefMesh}","page":"API","title":"PlantGeom.normals_vertex","text":"normals_vertex(mesh::Meshes.SimpleMesh)\n\nCompute per vertex normals and return them as a StaticArrays.SVector.\n\n#! This is a naive approach because I have no time right know. #! We just put the face mesh as a vertex mesh (and ovewritting values for common points)\n\nTODO: Use a real computation instead. See e.g.:\n\nhttps://stackoverflow.com/questions/45477806/general-method-for-calculating-smooth-vertex-normals-with-100-smoothness?noredirect=1&lq=1\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_geometry-Tuple{Any}","page":"API","title":"PlantGeom.parse_geometry","text":"Parse the geometry element of the OPF.\n\nNote\n\nThe transformation matrix is 3*4. elem = elem.content\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_materialBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_materialBDD!","text":"Parse the materialBDD using parse_opf_elements!\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_meshBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_meshBDD!","text":"Parse the meshBDD using parse_opf_array\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_array","page":"API","title":"PlantGeom.parse_opf_array","text":"Parse an array of values from the OPF into a Julia array (Arrays in OPFs are not following XML recommendations)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.parse_opf_attributeBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_opf_attributeBDD!","text":"Parse the opf attributes as a Dict.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_elements!-Tuple{Any, Any}","page":"API","title":"PlantGeom.parse_opf_elements!","text":"Generic parser for OPF elements.\n\nArguments\n\nopf::OrderedDict: the opf Dict (using [XMLDict.xml_dict])\nelem_types::Array: the target types of the element (e.g. \"[String, Int64]\")\n\nDetails\n\nelem_types should be of the same length as the number of elements found in each item of the subchild. elem_types = [Float64, Float64, Float64, Float64, Float64, Float64]\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_topology!","page":"API","title":"PlantGeom.parse_opf_topology!","text":"parse_opf_topology!(node, mtg, features, attr_type, mtg_type, ref_meshes, id_set=Set{Int}())\n\nParser of the OPF topology.\n\nArguments\n\nnode::ElementNode: the XML node to parse.\nmtg::Union{Nothing,Node}: the parent MTG node.\nfeatures::Dict: the features of the OPF.\nattr_type::DataType: the type of the attributes to use.\nmtg_type::DataType: the type of the MTG to use.\nref_meshes::Dict: the reference meshes.\nread_id::Bool: whether to read the ID from the OPF or recompute it on the fly.\nmax_id::RefValue{Int64}=Ref(1): the ID of the first node, if read_id==false.\n\nNote\n\nThe transformation matrices in geometry are 3*4.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.parse_ref_meshes-Tuple{Any}","page":"API","title":"PlantGeom.parse_ref_meshes","text":"parse_ref_meshes(mtg)\n\nParse the reference meshes of an OPF into RefMeshes.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.plantviz","page":"API","title":"PlantGeom.plantviz","text":"No docstring defined.\n\nPlot type\n\nThe plot type alias for the plantviz function is PlantViz.\n\nAttributes\n\nalpha =  nothing  — No docs available.\n\ncolor =  :slategray3  — No docs available.\n\ncolor_cache_name =  nothing  — The name of the color cache. Should be a string (default to a random string).\n\ncolor_missing =  RGBA(0, 0, 0, 0.3)  — The color to be used for missing values. Should be a colorant or a symbol of color.\n\ncolormap =  nothing  — No docs available.\n\ncolorrange =  nothing  — No docs available.\n\nfilter_fun =  nothing  — Filter the MTG nodes to be plotted using a function that takes a node as argument and returns a boolean\n\nindex =  nothing  — An integer giving the index of the attribute value to be vizualised. This is useful when the attribute is a vector of values for e.g. each timestep.\n\nlink =  nothing  — Filter the MTG nodes to be plotted by link\n\npointcolor =  :gray30  — No docs available.\n\npointmarker =  :circle  — No docs available.\n\npointsize =  4  — No docs available.\n\nscale =  nothing  — Filter the MTG nodes to be plotted by scale\n\nsegmentcolor =  :gray30  — No docs available.\n\nsegmentsize =  1.5  — No docs available.\n\nshowpoints =  false  — No docs available.\n\nshowsegments =  false  — No docs available.\n\nsymbol =  nothing  — Filter the MTG nodes to be plotted by symbol\n\nvisible =  true  — No docs available.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.plantviz!","page":"API","title":"PlantGeom.plantviz!","text":"plantviz! is the mutating variant of plotting function plantviz. Check the docstring for plantviz for further information.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.plot_opf","page":"API","title":"PlantGeom.plot_opf","text":"plot_opf(plot)\n\nActual workhorse function for plotting an OPF / MTG with geometry.\n\nArguments\n\nplot: The plot object.\n\nThe plot object can have the following optional arguments:\n\ncolor: The color to be used for the plot. Can be a colorant, an attribute of the MTG, or a dictionary of colors for each reference mesh.\nalpha: The alpha value to be used for the plot. Should be a float between 0 and 1.\ncolormap: The colorscheme to be used for the plot. Can be a Symbol or a ColorScheme.\ncolorrange: The range of values to be used for the colormap. Should be a tuple of floats (optionally with units if e.g. z position).\nsegmentcolor: The color to be used for the facets. Should be a colorant or a symbol of color.\nshowsegments: A boolean indicating whether the facets should be shown or not.\nsegmentsize: The size of the segments. Should be a float.\nshowpoints: A boolean indicating whether the points should be shown or not.\ncolor_missing: The color to be used for missing values. Should be a colorant or a symbol of color.\npointsize: The size of the points. Should be a float.\nindex: An integer giving the index of the attribute value to be vizualised. This is useful when the attribute is a vector of values for e.g. each timestep.\ncolor_cache_name: The name of the color cache. Should be a string (default to a random string).\nfilter_fun: A function to filter the nodes to be plotted. Should be a function taking a node as argument and returning a boolean.\nsymbol: Plot only nodes with this symbol. Should be a String or a vector of.\nscale: Plot only nodes with this scale. Should be an Int or a vector of.\nlink: Plot only nodes with this link. Should be a String or a vector of.\n\nExamples\n\n```julia using MultiScaleTreeGraph, PlantGeom, Colors\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n\nopf = read_opf(file)\n\nf, a, plot = plantviz(opf) plot_opf(p)\n\nf, a, plot = plantviz(opf, color=:red) plot_opf(plot)\n\nf, a, plot = plantviz(opf, color=:Length) plot_opf(plot)\n\nplot_opf(opf; color=Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.1,0.1,0.5)))\n\nplot_opf(opf; color=:red, colormap=:viridis)\n\nplot_opf(opf; color=:red, colormap=:viridis, segmentcolor=:red, showsegments=true)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.read_opf-Tuple{Any}","page":"API","title":"PlantGeom.read_opf","text":"read_opf(file; attr_type = Dict, mtg_type = MutableNodeMTG)\n\nRead an OPF file, and returns an MTG.\n\nArguments\n\nfile::String: The path to the opf file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nread_id::Bool = true: whether to read the ID from the OPF or recompute it on the fly.\nmax_id::RefValue{Int64}=Ref(1): the ID of the first node, if read_id==false.\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attributes a lot\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify  anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the MTG package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\nopf = read_opf(file)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_ops-Tuple{Any}","page":"API","title":"PlantGeom.read_ops","text":"read_ops(file; attr_type=Dict{String,Any}, mtg_type=MutableNodeMTG)\n\nReads an OPS file and returns the content as a MultiScaleTreeGraph.\n\nArguments\n\nfile::String: Path of the .ops file to read.\nattr_type::Type=Dict{Symbol,Any}: Type of the attributes to use.\nmtg_type::Type: Type of the MTG to use, e.g. NodeMTG or MutableNodeMTG.\n\nReturns\n\nA MultiScaleTreeGraph of the scene, with the OPFs as children of the scene node. The dimension of the scene is available in the scene_dimensions attribute of the scene node. Each root node of the OPFs has a scene_transformation attribute that stores the transformation applied to the OPF by the scene. It allows updating the scene transformations and write the scene back to disk. The OPF root node also has the following attributes:\n\nsceneID::Int: Scene ID.\nplantID::Int: Plant ID.\nfilePath::String: Path to the original .opf file.\npos::Meshes.Point: Position of the object.\nscale::Float64: Scale of the object.\ninclinationAzimut::Float64: Inclination azimut of the object.\ninclinationAngle::Float64: Inclination angle of the object.\nrotation::Float64: Rotation of the object.\nfunctional_group::String: Functional group of the object.\n\nDetails\n\nNode IDs of the OPFs are recomputed at import to ensure their uniqueness in the larger scene MTG.\n\nExample\n\nusing CairoMakie, PlantGeom\njoinpath(pathof(PlantGeom) |> dirname |> dirname, \"test\", \"files\", \"scene.ops\") |> read_ops |> plantviz\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_ops_file-Tuple{Any}","page":"API","title":"PlantGeom.read_ops_file","text":"read_ops_file(file)\n\nRead the content of an .ops file and return a tuple with the scene dimensions and the object table.\n\nArguments\n\nfile::String: Path of the .ops file to read.\n\nReturns\n\nThe scene dimensions and the object table as a tuple. The scene dimensions are a tuple of two Meshes.Point with the origin point and opposite point of the scene.  The object table is an array of NamedTuple with the following fields:\n\nsceneID::Int: Scene ID.\nplantID::Int: Plant ID.\nfilePath::String: Path to the .opf file.\npos::Meshes.Point: Position of the object.\nscale::Float64: Scale of the object.\ninclinationAzimut::Float64: Inclination azimut of the object.\ninclinationAngle::Float64: Inclination angle of the object.\nrotation::Float64: Rotation of the object.\nfunctional_group::String: Functional group of the object.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.refmesh_to_mesh","page":"API","title":"PlantGeom.refmesh_to_mesh","text":"refmesh_to_mesh!(node)\nrefmesh_to_mesh(node)\n\nCompute a node mesh based on the reference mesh, the transformation matrix and the tapering. The mutating version adds the new mesh to the mesh field of the geometry attribute of the node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nnode = opf[1][1][1]\n\nnew_mesh = refmesh_to_mesh(node)\n\nusing GLMakie\nplantviz(new_mesh)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.refmesh_to_mesh!","page":"API","title":"PlantGeom.refmesh_to_mesh!","text":"refmesh_to_mesh!(node)\nrefmesh_to_mesh(node)\n\nCompute a node mesh based on the reference mesh, the transformation matrix and the tapering. The mutating version adds the new mesh to the mesh field of the geometry attribute of the node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nnode = opf[1][1][1]\n\nnew_mesh = refmesh_to_mesh(node)\n\nusing GLMakie\nplantviz(new_mesh)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.rotate_point-NTuple{5, Any}","page":"API","title":"PlantGeom.rotate_point","text":"Rotate a point (x1,y1) around (x0, y0) with angle.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.taper-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.taper","text":"Returns a tapered mesh using dDwn and dUp based on the geometry of an input mesh. Tapering a mesh transforms it into a tapered version (i.e. pointy) or enlarged object, e.g. make a cone from a cylinder.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.transform_mesh!-Tuple{MultiScaleTreeGraph.Node, Any}","page":"API","title":"PlantGeom.transform_mesh!","text":"transform_mesh!(node::Node, transformation)\n\nAdd a new transformation to the node geometry transformation field.  The transformation is composed with the previous transformation if any.\n\ntransformation must be a function.\n\nIt is also possible to invert a transformation using revert from Meshes.jl.\n\nExamples\n\nusing PlantGeom, MultiScaleTreeGraph, GLMakie, Rotations, Meshes\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"simple_plant.opf\")\nopf = read_opf(file)\n\n# Visualize the mesh as is:\nplantviz(opf)\n\n# Copy the OPF, and translate the whole plant by 15 in the y direction (this is in cm, the mesh comes from XPlo):\nclean_cache!(opf) # Clean the cache to remove the observables that where cached by the previous `plantviz` call (necessary for the `deepcopy`).\nopf2 = deepcopy(opf)\ntransform!(opf2, x -> transform_mesh!(x, Translate(0, 15, 0)))\nplantviz!(opf2) # Visualize it again in the same figure\n\n# Same but rotate the whole plant around the X axis:\nclean_cache!(opf)\nopf3 = deepcopy(opf)\ntransform!(opf3, x -> transform_mesh!(x, Rotate(RotX(0.3))))\n# NB: we use Rotations.jl's RotX here. Input in radian, use rad2deg and deg2rad if needed.\nplantviz!(opf3)\n\n# Same but rotate only the second leaf around the Z axis:\nclean_cache!(opf)\nopf4 = deepcopy(opf)\n# Build the meshes from the reference meshes (need it because we want the coordinates of the parent):\ntransform!(opf4, refmesh_to_mesh!)\n\n# Get the second leaf in the OPF:\nleaf_node = get_node(opf4, 8)\n\n# Get the parent node (internode) Z coordinates:\nparent_zmax = zmax(leaf_node.parent)\n\n# Define a rotation of the mesh around the Z axis defined by the parent node max Z:\ntransformation = recenter(Rotate(RotZ(1.0)), Point(0.0, 0.0, parent_zmax))\n\n# Update the transformation matrix of the leaf and its mesh:\ntransform_mesh!(leaf_node, transformation)\n\n# Plot the result:\nplantviz(opf)\nplantviz!(opf4)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.write_opf-Tuple{Any, Any}","page":"API","title":"PlantGeom.write_opf","text":"write_opf(file, opf)\n\nWrite an MTG with explicit geometry to disk as an OPF file.\n\nNotes\n\nNode attribute :geometry is treated as a reserved keyword and should not be used without knowing their meaning.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nwrite_opf(\"test.opf\", opf)\nopf2 = read_opf(\"test.opf\")\nplantviz(opf2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.write_ops-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.write_ops","text":"write_ops(file, scene_dimensions, object_table)\n\nWrite a scene file (.ops), with the given dimensions and object table.\n\nArguments\n\nfile::String: Path of the .ops file to write.\nscene_dimensions::Tuple{Meshes.Point{3,T},Meshes.Point{3,T}}: Dimensions of the scene.\nobject_table: Table with the objects to write in the .ops file. The table may have the following columns:\nsceneID::Int: Scene ID (mandatory).\nplantID::Int: Plant ID (mandatory).\nfilePath::String: Path to the .opf file (mandatory).\npos::Meshes.Point{3,T}: Position of the object (mandatory).\nfunctional_group::String: Functional group of the object, used to map the object to the models (mandatory).\nscale::T: Scale of the object (optional, 0.0 as default).\ninclinationAzimut::T: Inclination azimut of the object (optional, 0.0 as default).\ninclinationAngle::T: Inclination angle of the object (optional, 0.0 as default).\nrotation::T: Rotation of the object (optional, 0.0 as default).\n\nDetails\n\nobject_table can be of any format that implement the Tables.jl interface, e.g. an array of NamedTuples, a DataFrame...\n\nExample\n\nusing Meshes\nusing Tables\nusing PlantGeom\n\nscene_dimensions = (Meshes.Point(0.0, 0.0, 0.0), Meshes.Point(100.0, 100.0, 100.0))\npositions = [Meshes.Point(50.0, 50.0, 50.0), Meshes.Point(60.0, 60.0, 60.0), Meshes.Point(70.0, 70.0, 70.0)]\nobject_table = [\n    (sceneID=1, plantID=p, filePath=\"opf/plant_$p.opf\", pos=positions[p], functional_group=\"plant\", rotation=0.1) for p in 1:3\n]\n\nwrite_ops(\"scene.ops\", scene_dimensions, object_table)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.xmax","page":"API","title":"PlantGeom.xmax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.xmin","page":"API","title":"PlantGeom.xmin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.ymax","page":"API","title":"PlantGeom.ymax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.ymin","page":"API","title":"PlantGeom.ymin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.zmax","page":"API","title":"PlantGeom.zmax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.zmin","page":"API","title":"PlantGeom.zmin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#RecipesBase.plot","page":"API","title":"RecipesBase.plot","text":"plot(opf::MultiScaleTreeGraph.Node; kwargs...)\nplot!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree, paired with a Plots.jl backend.\n\nSee also diagram for the same plot with a Makie.jl backend.\n\nAttributes\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nExamples\n\n# import Pkg; Pkg.add(\"PlotlyJS\")\nusing Plots, PlantGeom\nplotlyjs()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\nplot(opf, node_color = :Length)\n\n\n\n\n\n","category":"function"},{"location":"API/#RecipesBase.plot!","page":"API","title":"RecipesBase.plot!","text":"plot(opf::MultiScaleTreeGraph.Node; kwargs...)\nplot!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree, paired with a Plots.jl backend.\n\nSee also diagram for the same plot with a Makie.jl backend.\n\nAttributes\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nExamples\n\n# import Pkg; Pkg.add(\"PlotlyJS\")\nusing Plots, PlantGeom\nplotlyjs()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\nplot(opf, node_color = :Length)\n\n\n\n\n\n","category":"function"}]
}
