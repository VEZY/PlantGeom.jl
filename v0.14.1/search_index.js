var documenterSearchIndex = {"docs":
[{"location":"geometry/geometry/#Geometry-Concepts-in-PlantGeom","page":"Concepts","title":"Geometry Concepts in PlantGeom","text":"","category":"section"},{"location":"geometry/geometry/#Overview","page":"Concepts","title":"Overview","text":"PlantGeom provides a framework for representing, manipulating, and visualizing 3D plant architecture. This page introduces the key concepts behind PlantGeom's approach to geometry handling.","category":"section"},{"location":"geometry/geometry/#Reference-Mesh-Design-Philosophy","page":"Concepts","title":"Reference Mesh Design Philosophy","text":"Most plants contain many similar organs - think of hundreds of leaves on a tree that share the same basic shape but differ in size and orientation. PlantGeom leverages this biological pattern through its reference mesh approach:\n\nDefine a single reference mesh for each organ type (e.g., a generic leaf shape)\nApply transformations (scaling, rotation, translation) to position each instance\n\nThis approach offers significant benefits:\n\nMemory efficiency: Store one mesh instead of hundreds of copies\nSmaller file sizes: OPF files store only unique reference meshes plus transformations\nPerformance: Operations can be applied to reference meshes once rather than to many instances\n\nFor highly specialized shapes that can't be derived from a reference (like wheat leaves with complex curvatures), PlantGeom can still use direct mesh representations.","category":"section"},{"location":"geometry/geometry/#Key-Components","page":"Concepts","title":"Key Components","text":"PlantGeom's geometry system consists of three main components:\n\nRefMesh: A reference mesh with a unique identifier and the mesh data\nGeometry: A container that links a RefMesh to a node and stores transformation information\nTransformations: Operations that scale, rotate, and position instances of reference meshes","category":"section"},{"location":"geometry/geometry/#MTG-Integration","page":"Concepts","title":"MTG Integration","text":"Geometries in PlantGeom are attached to nodes in a Multi-scale Tree Graph (MTG) that represents plant topology:\n\n# Attaching geometry to an MTG node\nnode.geometry = Geometry(ref_mesh=some_ref_mesh, transformation=some_transformation)","category":"section"},{"location":"geometry/geometry/#Documentation-Structure","page":"Concepts","title":"Documentation Structure","text":"To learn more about PlantGeom's geometry features:\n\nReference Meshes: Learn how to create and work with reference meshes\nBuilding Plant Models: Step-by-step guide to constructing complete plant geometries\nMerging Meshes: Tools for combining geometries at different scales","category":"section"},{"location":"geometry/geometry/#File-Format-Support","page":"Concepts","title":"File Format Support","text":"PlantGeom works with several file formats:\n\nOPF: Open Plant Format - combines MTG structure and geometry efficiently\nOBJ/PLY/STL: Common 3D mesh formats","category":"section"},{"location":"geometry/geometry/#Basic-Usage-Example","page":"Concepts","title":"Basic Usage Example","text":"using PlantGeom\nusing CairoMakie\n\n# Load a plant model with geometry\nmtg = read_opf(\"path/to/plant.opf\")\n\n# Visualize\nfig = Figure()\nax = Axis3(fig[1, 1])\nplantviz!(ax, mtg)\nfig\n\nFor more visualization options, see the 3D recipes section.","category":"section"},{"location":"geometry/building_plant_models/#Building-Plant-Models","page":"Building Plant Models","title":"Building Plant Models","text":"","category":"section"},{"location":"geometry/building_plant_models/#Overview","page":"Building Plant Models","title":"Overview","text":"This guide explains how to build complete plant geometries by combining reference meshes with transformations and associating them with nodes in a MultiScaleTreeGraph (MTG) structure. PlantGeom makes it easy to create realistic 3D plant models by leveraging reference meshes for different organ types and applying appropriate transformations.","category":"section"},{"location":"geometry/building_plant_models/#Geometry-in-MTG-Nodes","page":"Building Plant Models","title":"Geometry in MTG Nodes","text":"In PlantGeom, 3D geometries are attached to MTG nodes through the :geometry attribute. Each node's geometry is represented by a Geometry object, which typically contains:\n\nA reference to a RefMesh that defines the base shape\nA transformation that positions, scales, and orients the mesh\n\n# The core Geometry type\nPlantGeom.Geometry(; \n    ref_mesh::RefMesh,                  # The reference mesh to use\n    transformation=Identity(),          # Transformation to apply to the reference mesh (here, no transformation)\n)\n\nGeometry also has the dUp and dDwn arguments for appyling tapering to the geometry (i.e. make it pointy), but it is rarely used in practice, and is there for backward compatibility with the OPF file format. It also has the mesh field, which is used to store the mesh resulting from applying the transformation to the reference mesh. This one is lazily computed because we prefer not store it unless we really have to.","category":"section"},{"location":"geometry/building_plant_models/#Creating-Plant-Organ-Geometries","page":"Building Plant Models","title":"Creating Plant Organ Geometries","text":"The typical workflow for building a plant geometry is:\n\nCreate reference meshes for each organ type (e.g., stem, leaf, root)\nTraverse the MTG structure\nFor each node, create a Geometry with the appropriate reference mesh and transformation","category":"section"},{"location":"geometry/building_plant_models/#Step-1:-Create-Reference-Meshes","page":"Building Plant Models","title":"Step 1: Create Reference Meshes","text":"First, define a reference mesh for each type of plant organ:\n\nusing PlantGeom\nusing Meshes, Colors\n\n# Create a cylinder reference mesh for internodes and roots, oriented towards the z direction\ncylinder = Meshes.CylinderSurface(Meshes.Point(0.0, 0.0, 0.0), Meshes.Point(0.0, 0.0, 1.0), 0.5) |> \n           Meshes.discretize |> Meshes.simplexify\nrefmesh_cylinder = RefMesh(\"Cylinder\", cylinder, RGB(0.5, 0.5, 0.5))\n# RGB(0, 0.5, 0), RGB(0, 0.5, 0.1), RGB(0.1, 0.5, 0)]\n# Make a reference mesh for the leaves:\nw = l = 1 # Leaf width and length are set to 1.0 to facilitate transformations\np = 0.2 * l # Petiole length is set to 20% of the leaf length\npoints = [\n        (0.0, -0.05 * w, 0.0), # Petiole base 1\n        (0.0, 0.05 * w, 0.0), # Base 2. NB: the petiole base width is 5% of the leaf width \n        (p, 0.0, 0.0), # End of petiole, first point of leaf blade\n        (p + l, 0.0, 0.0), # tip of the leaf\n        (p + l / 2.0, -w / 2.0, 0.0),\n        (p + l / 2.0, w / 2.0, 0.0)\n    ]\n\nconnec = Meshes.connect.(\n    [\n        (1, 2, 3), # Petiole\n        (3, 5, 4), # left part of the leaf\n        (3, 6, 4)  # right part of the leaf\n    ],\n    Triangle\n)\n\nrefmesh_leaf = RefMesh(\"Leaf\", Meshes.SimpleMesh(points, connec), RGB(0.1, 0.5, 0))","category":"section"},{"location":"geometry/building_plant_models/#Step-2:-Make-a-plant-graph","page":"Building Plant Models","title":"Step 2: Make a plant graph","text":"For this example, we'll create a very simple plant that has only one meristem going upward, producing one internode and one leaf per internode, and one root meristem going downward.\n\nusing MultiScaleTreeGraph\n\nfunction build_mtg(n_internode=5, n_roots = 3)\n    # Starting with the plant scale:\n    mtg = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\n\n    # Then, adding internodes and leaves recursively:\n    last_node = mtg\n    for i in 1:n_internode\n        internode = Node(last_node, NodeMTG(i == 1 ? \"/\" : \"<\", \"Internode\", i, 2))\n        Node(internode, NodeMTG(\"+\", \"Leaf\", i, 2)) # Branching with a leaf\n        last_node = internode\n    end\n\n    # And finally, adding the roots:\n    last_root = mtg\n    for i in 1:n_roots\n        last_root = Node(last_root, NodeMTG(i == 1 ? \"/\" : \"<\", \"RootSegment\", i, 2))\n    end\n\n    return mtg\nend\n\n# Now let's use our function to create a plant:\n\nmtg = build_mtg()","category":"section"},{"location":"geometry/building_plant_models/#Step-3:-Associate-Geometries-with-MTG-Nodes","page":"Building Plant Models","title":"Step 3: Associate Geometries with MTG Nodes","text":"Next, traverse the MTG and assign the appropriate geometry to each node:\n\nusing MultiScaleTreeGraph\nimport TransformsBase: → # The → operator from TransformsBase composes transformations\nusing Rotations\n\nfunction add_geometry!(mtg, refmesh_cylinder, refmesh_leaf)\n    # Track the current height for positioning internodes\n    current_height = 0.0\n    internode_width = 0.1\n    internode_length = 0.3\n    root_width = 0.05\n    root_length = 0.5\n    root_depth = -0.5  # Start below ground\n    phyllotaxy = 0.0\n\n    traverse!(mtg) do node\n        if symbol(node) == \"Internode\"\n            # Scale and position the internode\n            transformation = Meshes.Scale(internode_width, internode_width, internode_length) → \n            Meshes.Translate(0.0, 0.0, current_height)\n            \n            # Attach geometry to this node\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_cylinder, transformation=transformation)\n            \n            # Update the height for the next internode\n            current_height += internode_length\n            phyllotaxy += π/2\n\n        elseif symbol(node) == \"Leaf\"\n            # Scale, rotate, and position the leaf\n            leaf_length = 0.20 + 0.10*current_height\n            leaf_width = 0.5 * leaf_length\n            transformation = Meshes.Scale(leaf_length, leaf_width, 1e-6) → \n                             Meshes.Rotate(RotY(-π/4)) → # Give an insertion angle to the leaf\n                             Meshes.Translate(internode_width/2.0, 0.0, current_height) → # Position on the stem\n                             Meshes.Rotate(RotZ(phyllotaxy))                            \n            # Attach geometry to this node\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_leaf, transformation=transformation)\n        elseif symbol(node) == \"RootSegment\"\n            # Scale and position the root (going downward)            \n            transformation = Meshes.Scale(root_width, root_width, root_length) →\n                             Meshes.Translate(0.0, 0.0, root_depth) →\n                             Meshes.Rotate(RotZ(π))  # Point downward\n            \n            # Attach geometry to this node\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_cylinder, transformation=transformation)\n            \n            # Update the depth for the next root segment\n            root_depth -= root_length\n        end\n    end\nend","category":"section"},{"location":"geometry/building_plant_models/#Step-4:-Visualize-the-Plant","page":"Building Plant Models","title":"Step 4: Visualize the Plant","text":"We can build a plant and compute the geometry of each node using the previous two functions:\n\nmtg = build_mtg()\nadd_geometry!(mtg, refmesh_cylinder, refmesh_leaf)\n\nAnd finally, we can visualize our plant:\n\nusing PlantGeom, CairoMakie  # or GLMakie for interactive 3D, or WGLMakie for web\n\n# Visualize the plant\nfig = Figure()\nax = Axis3(fig[1, 1], aspect=:data)\nplantviz!(ax, mtg)\nfig","category":"section"},{"location":"geometry/building_plant_models/#Working-with-Direct-Meshes","page":"Building Plant Models","title":"Working with Direct Meshes","text":"In some cases, you may want to use the transformed mesh directly rather than reference meshes. This is particularly useful for complex or unique organ shapes such as grass leaves. In this case, you can provide the mesh as a reference mesh:\n\n# Direct mesh approach\ncomplex_leaf_mesh = load_mesh(\"complex_leaf.obj\")\n\n# During MTG traversal:\nnode.geometry = PlantGeom.Geometry(ref_mesh=complex_leaf_mesh)\n\nBy default, Geometry uses the Identity transformation, which means no transformation.","category":"section"},{"location":"geometry/building_plant_models/#Tips-for-Building-Realistic-Plant-Geometries","page":"Building Plant Models","title":"Tips for Building Realistic Plant Geometries","text":"Understand mesh orientation: Know the default orientation of your reference meshes to apply transformations correctly\nUse transformation composition: The → operator allows clean composition of multiple transformations\nScale appropriately: Make sure organ scales match realistically with each other\nPhyllotaxy patterns: Implement botanical phyllotaxy patterns (opposite, alternate, whorled, etc.)\nCalibrate transformations: You may need to experiment with transformation parameters to get realistic positioning","category":"section"},{"location":"geometry/building_plant_models/#Conclusion","page":"Building Plant Models","title":"Conclusion","text":"By combining reference meshes with appropriate transformations, you can build complex and realistic 3D plant models efficiently. The use of reference meshes saves memory and computational resources while still allowing for detailed and visually appealing plant representations.","category":"section"},{"location":"geometry/building_plant_models/#More-examples","page":"Building Plant Models","title":"More examples","text":"You can look at VPalm.jl to get an idea of a more complex 3D reconstruction of a plant using sequential architectural allometries.","category":"section"},{"location":"geometry/merging_geometry/#Merging-Fine-Scale-Geometry","page":"Merging Meshes","title":"Merging Fine-Scale Geometry","text":"","category":"section"},{"location":"geometry/merging_geometry/#Overview","page":"Merging Meshes","title":"Overview","text":"Plant architecture is often represented at multiple scales - from fine details like individual leaflets to coarser representations like whole leaves or branches. While detailed structural representation is valuable, there are significant computational benefits to merging fine-scale geometries into coarser scales:\n\nComputational efficiency: Processing a single merged mesh is faster than handling many small ones\nScale-appropriate analysis: When analysis is performed at a coarser scale (e.g., axis level), there's no need to maintain separate geometries for each component\nStreamlined visualization: Rendering performance improves significantly with fewer meshes\n\nPlantGeom provides tools to merge fine-scale geometries into coarser representations while preserving the complete geometric detail. Note: the PlantViz plotting recipe renders using a single merged mesh by default for performance; the utilities in this page are about structurally merging geometry across MTG scales.","category":"section"},{"location":"geometry/merging_geometry/#The-merge_children_geometry!-Function","page":"Merging Meshes","title":"The merge_children_geometry! Function","text":"Advanced: structural merging across scales\n\nThe merge_children_geometry! function allows you to merge geometries from lower-scale nodes into higher-scale parent nodes without losing geometric detail. This is useful when reconstruction happens at a fine scale (e.g., metamers/leaves) but you want to persist geometry at a coarser organizational scale (e.g., axis) for downstream processing or storage.\n\nNote: This is not required to get responsive plots. PlantViz renders using a single merged mesh by default at draw time and does not need structural merging for interactive performance. Use merge_children_geometry! only when you deliberately want to relocate geometry across MTG scales.\n\nmerge_children_geometry!(mtg; from, into, delete=:nodes, verbose=true, child_link_fun=x -> new_child_link(x, verbose))","category":"section"},{"location":"geometry/merging_geometry/#Parameters","page":"Merging Meshes","title":"Parameters","text":"mtg: The MultiScaleTreeGraph to process.\nfrom: The type(s) of nodes whose geometry should be merged upward (lower scale). Can be a string or a vector of strings, e.g. [\"Metamer\", \"Leaf\"].\ninto: The type of nodes to merge into (higher scale). Must be a single string, e.g. \"Axis\".\ndelete: A symbol indicating what to do after merging:\n:none: Keep both the original nodes and their geometry.\n:geometry: Keep the original nodes but remove their geometry (saves memory).\n:nodes: Delete the original nodes entirely (requires a child_link_fun).\nverbose: A boolean indicating whether to print progress messages.\nchild_link_fun: A function that handles reconnecting children when nodes are deleted. The default function is new_child_link from the MultiScaleTreeGraph.jl package, which tries to be clever on relinking the children nodes.","category":"section"},{"location":"geometry/merging_geometry/#Example:-Merging-Coffee-Plant-Geometry","page":"Merging Meshes","title":"Example: Merging Coffee Plant Geometry","text":"Let's walk through an example using a coffee plant model where we merge the geometry of metamers and leaves into their parent axis.","category":"section"},{"location":"geometry/merging_geometry/#Original-Plant-Model","page":"Merging Meshes","title":"Original Plant Model","text":"First, let's look at the original coffee plant model with geometry at the metamer and leaf level:\n\nusing PlantGeom\nusing CairoMakie\n\n# Load the coffee plant model\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"coffee.opf\"))\n\n# Visualize the original model\nfig = Figure(size=(600, 600))\nax = Axis3(fig[1, 1], aspect=:data, title=\"Original Coffee Plant\")\nplantviz!(ax, mtg)\nhidedecorations!(ax)\nhidespines!(ax)\nfig\n\nIn this visualization, each metamer and leaf has its own individual mesh. This results in thousands of small meshes that need to be processed and rendered separately.","category":"section"},{"location":"geometry/merging_geometry/#Merging-Geometry-while-Keeping-Nodes","page":"Merging Meshes","title":"Merging Geometry while Keeping Nodes","text":"We can merge the geometry from metamers and leaves up to the axis level while keeping the original node structure intact:\n\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"coffee.opf\"))\n\n# Create a copy to preserve the original\nmtg_merged1 = deepcopy(mtg)\n\n# Merge geometry from \"Metamer\" and \"Leaf\" into \"Axis\"\nmerge_children_geometry!(mtg_merged1; \n    from=[\"Metamer\", \"Leaf\"], \n    into=\"Axis\", \n    delete=:geometry, \n)\n\n# Visualize the result\nfig = Figure(size=(600, 600))\nax = Axis3(fig[1, 1], aspect=:data, title=\"Merged Geometry (Keeping Nodes)\")\nplantviz!(ax, mtg_merged1)\nhidedecorations!(ax)\nhidespines!(ax)\nfig\n\nThe plant looks identical, but the geometry is now stored at the axis level rather than at individual metamers and leaves. The original nodes still exist in the MTG structure, but their geometry properties have been removed to save memory.","category":"section"},{"location":"geometry/merging_geometry/#Merging-Geometry-and-Deleting-Nodes","page":"Merging Meshes","title":"Merging Geometry and Deleting Nodes","text":"For even more streamlined representation, we can completely remove the lower-scale nodes:\n\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"coffee.opf\"))\n\n# Create a copy to preserve the original\nmtg_merged2 = deepcopy(mtg)\n\n# Merge geometry and delete the original nodes\nmerge_children_geometry!(mtg_merged2; \n    from=[\"Metamer\", \"Leaf\"], \n    into=\"Axis\", \n    delete=:nodes, \n)\n\n# Visualize the result\nfig = Figure(size=(600, 600))\nax = Axis3(fig[1, 1], aspect=:data, title=\"Merged Geometry (Nodes Deleted)\")\nplantviz!(ax, mtg_merged2)\nhidedecorations!(ax)\nhidespines!(ax)\nfig\n\nThe visual result is still the same, but now the MTG structure has been simplified by removing the metamer and leaf nodes entirely. The complete geometry is preserved at the axis level.","category":"section"},{"location":"geometry/merging_geometry/#Performance-Comparison","page":"Merging Meshes","title":"Performance Comparison","text":"If your MTG has many little meshes, you will see performance improvements from merging these into a higher-level scale, because they will be merged into a single mesh. But for many cases, you will not see a big difference if your use-case is only plotting a single figure.\n\nusing Statistics\n# Run benchmarks (would be better to use BenchmarkTools, but this is an approximation)\noriginal_time = @elapsed plantviz(mtg)\nmerged1_time = @elapsed plantviz(mtg_merged1)\nmerged2_time = @elapsed plantviz(mtg_merged2)\n\n# Display the table\ntable_fig = Figure(size=(600, 200))\nax = Axis(table_fig[1, 1], title=\"Rendering Time (ms)\", xticks = (1:3, [\"Original Model\", \"Merged (Keeping Nodes)\", \"Merged (Nodes Deleted)\"]))\nbarplot!(ax, 1:3, [original_time, merged1_time, merged2_time])\ntable_fig","category":"section"},{"location":"geometry/merging_geometry/#Notes","page":"Merging Meshes","title":"Notes","text":"Merging preserves all geometric detail but organizes it at a coarser scale\nThe MTG structure can be maintained (using delete=:geometry) or simplified (using delete=:nodes)\nWhen deleting nodes, make sure to provide an appropriate child_link_fun to maintain connectivity. The default function new_child_link tries to be smart, but it may not suit your specific use case.","category":"section"},{"location":"plot_diagram/makie_diagram/#Makie.jl-recipes","page":"Makie.jl","title":"Makie.jl recipes","text":"","category":"section"},{"location":"plot_diagram/makie_diagram/#Diagram","page":"Makie.jl","title":"Diagram","text":"We can make a diagram of the MTG graph using the diagram function:\n\nusing PlantGeom, CairoMakie\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\ndiagram(opf)\n\nWe can change the color of the nodes:\n\ndiagram(opf, color = :palegreen1)\n\nThe color argument is for the node color. The edges are colored with the same color than the nodes by default, but you can also use a different color if you want using edge_color:\n\ndiagram(opf, color = :palegreen1, edge_color = :sienna)\n\nYou can also color your nodes based on an attribute from the MTG, e.g. using the nodes Z coordinates:\n\n# First, we compute \"fake\" coordinates for each node in the MTG (just for ploting):\nPlantGeom.coordinates!(opf, force = true)\n# Then we plot the MTG using the newly created ZZ attribute:\ndiagram(opf, color = :YY)\n\nWe can also color the edges differently, e.g. using the XX attribute computed using coordinates!:\n\nPlantGeom.coordinates!(opf, force = true)\ndiagram(opf, color = :YY, edge_color = :XX)\n\nAttributes used for coloring may have missing values. In this case you can choose their color using color_missing, e.g.:\n\ndiagram(opf, color = :Length, edge_color = :Width, color_missing = :red)","category":"section"},{"location":"geometry/refmesh/#RefMesh","page":"Reference Meshes","title":"RefMesh","text":"","category":"section"},{"location":"geometry/refmesh/#Overview","page":"Reference Meshes","title":"Overview","text":"RefMesh is a core type in PlantGeom.jl that represents a reference mesh. It combines a mesh geometry with metadata such as an identifier, making it suitable for use in plant architecture models.","category":"section"},{"location":"geometry/refmesh/#Reference-Mesh-Concept","page":"Reference Meshes","title":"Reference Mesh Concept","text":"PlantGeom implements an efficient approach to representing plant geometry based on the insight that most organs of the same type (e.g., leaves, internodes) share a common shape that varies only in size, orientation, and position. Instead of storing complete, unique mesh data for each organ instance, PlantGeom uses:\n\nA reference mesh that defines the canonical shape of the organ type\nTransformation matrices for each instance that scale, rotate, and translate this reference into the correct position\n\nThis method is especially powerful for plants like trees with thousands of similar leaves, where storing a unique mesh for each leaf would consume enormous amounts of memory.","category":"section"},{"location":"geometry/refmesh/#Benefits-of-the-Reference-Mesh-Approach","page":"Reference Meshes","title":"Benefits of the Reference Mesh Approach","text":"Memory efficiency: Only one mesh is stored for many organs with the same shape\nSmaller file sizes: The OPF file format leverages this concept, storing only unique reference meshes plus transformation matrices\nComputational optimization: Operations can be applied to one mesh rather than thousands of individual copies","category":"section"},{"location":"geometry/refmesh/#Handling-Special-Cases","page":"Reference Meshes","title":"Handling Special Cases","text":"For organs with unique shapes that cannot be easily derived from scaling and transforming a reference (such as wheat leaves with complex curvature angles), PlantGeom accommodates this by:\n\nUsing the actual specific mesh as the reference mesh\nUsing an identity transformation matrix (no transformation)\n\nThis flexibility ensures that PlantGeom can represent both regular, repeating structures and unique, complex shapes within the same model.","category":"section"},{"location":"geometry/refmesh/#Structure","page":"Reference Meshes","title":"Structure","text":"A RefMesh contains:\n\nid: A string identifier for the mesh\nmesh: The actual mesh data structure (typically a SimpleMesh from Meshes.jl)\n\nwarning: Warning\nThe RefMesh is usually oriented with its length along the X direction, its width along the Y direction, and its height along the Z direction. This orientation is important for ensuring that transformations and visualizations behave as expected. You can still orient the mesh in any direction, but you'll have to handle the transformations appropriately.","category":"section"},{"location":"geometry/refmesh/#Creating-a-RefMesh","page":"Reference Meshes","title":"Creating a RefMesh","text":"There are several ways to create a RefMesh.","category":"section"},{"location":"geometry/refmesh/#From-an-Existing-Mesh","page":"Reference Meshes","title":"From an Existing Mesh","text":"You can create a RefMesh from an existing mesh object. This is useful when you have a mesh already defined and want to wrap it in a RefMesh for use in PlantGeom:\n\nusing PlantGeom\nusing GeoIO\n\n# Read a mesh from a file: \ngeotable = GeoIO.load(\"flower.ply\")\n# Create a RefMesh from an existing mesh:\nref_mesh = RefMesh(\"flower\", geotable.geometry)\n\nYou can find an example for the trunk snags in VPalm here.","category":"section"},{"location":"geometry/refmesh/#From-Vertices-and-Faces","page":"Reference Meshes","title":"From Vertices and Faces","text":"You can manually create a mesh from vertices and faces first, and pass it to the RefMesh. This is useful for defining simple shapes or custom meshes.\n\nFor example we can creata a plane mesh with 4 vertices and 2 triangles:\n\nusing Meshes\nmesh_vertices = [\n    Meshes.Point(0.0, 0.0, -0.5),  # Left bottom\n    Meshes.Point(1.0, 0.0, -0.5),   # Right bottom\n    Meshes.Point(1.0, 0.0, 0.5),   # Right top\n    Meshes.Point(0.0, 0.0, 0.5)   # Left top\n]\n\n# Create triangular faces\n# Two triangles to form the rectangle\nmesh_faces = [\n    Meshes.connect((1, 2, 3), Meshes.Triangle),\n    Meshes.connect((1, 3, 4), Meshes.Triangle)\n]\n\n# Create the mesh\nmesh = Meshes.SimpleMesh(mesh_vertices, mesh_faces)\n\nref_mesh = RefMesh(\"plane\", mesh)\n\nplantviz(ref_mesh)\n\nThis is used to create simple leaflets elements in VPalm.","category":"section"},{"location":"geometry/refmesh/#From-Primitive-Shapes","page":"Reference Meshes","title":"From Primitive Shapes","text":"You can also create a RefMesh directly from primitive shapes like spheres, cylinders, or cones. This is useful for quickly generating common geometric forms. The only thing to remember is to use the discretize function to create a mesh from the primitive shape, and then use the simplexify function to convert it to a triangulated mesh.\n\nTo create a sphere:\n\nusing Meshes\nsphere_mesh = Meshes.Sphere((0.0, 0.0, 0.0), 1.0) |> Meshes.discretize |> Meshes.simplexify\nsphere_refmesh = RefMesh(\"sphere_1\", sphere_mesh)\nplantviz(sphere_refmesh)\n\nOr a cylinder:\n\ncyl = Meshes.CylinderSurface((0.0, 0.0, 0.0), (0.0, 0.0, 1.0), 0.5) |> Meshes.discretize |> Meshes.simplexify\ncylinder_refmesh = RefMesh(\"cylinder_1\", cyl)\n\nplantviz(cylinder_refmesh)","category":"section"},{"location":"geometry/refmesh/#Working-with-RefMesh","page":"Reference Meshes","title":"Working with RefMesh","text":"","category":"section"},{"location":"geometry/refmesh/#Accessing-Properties","page":"Reference Meshes","title":"Accessing Properties","text":"# Get the ID\nname = cylinder_refmesh.name\n\n# Get the underlying reference mesh\nmesh = cylinder_refmesh.mesh\n\n# Or any other property of the mesh:\nfieldnames(typeof(cylinder_refmesh))\n\n# Get vertices\nverts = vertices(cylinder_refmesh.mesh)\n\n# Get faces\nfaces = Meshes.topology(cylinder_refmesh.mesh)","category":"section"},{"location":"architecture/#Architecture-Overview","page":"Architecture","title":"Architecture Overview","text":"This package bridges Plant MTGs with meshes and high‑performance visualization.\n\nOPF/OPS files ──► read_opf/read_ops ──► MTG (MultiScaleTreeGraph)\n                                  │\n                                  ▼\n                         Reference Meshes (RefMesh)\n                                  │\n                                  ▼\n                    Geometry (ref_mesh + transform)\n                                  │\n                    (lazy) refmesh_to_mesh per node\n                                  │\n                                  ▼\n            Merge all meshes into a single Meshes.SimpleMesh geometry\n                                  │\n                                  ▼\n             plantviz (Makie recipe) ──► Makie Figure/Axis\n\nCore types: RefMesh stores template geometry; Geometry attaches a ref_mesh, a transform (Translate, Rotate, Scale, Affine, or SequentialTransform), and an optional cached mesh to an MTG node attribute :geometry.\nIO: read_opf/read_ops populate MTG nodes and scene transforms; write_opf/write_ops serialize meshes and transforms back to disk.\nComputation: meshes are computed lazily; call refmesh_to_mesh to materialize. Matrix generation uses get_transformation_matrix. At render time, node meshes are merged to a single SimpleMesh.\nVisualization: plantviz builds on Makie’s ComputeGraph. It maps colors from attributes or user dictionaries via get_mtg_color/get_color/get_colormap, wires them as compute nodes with map!, and renders the merged mesh once.\n\nMinimal example\n\nusing PlantGeom\nopf = read_opf(\"test/files/simple_plant.opf\")\nfig, ax, plt = plantviz(opf)       # visualize","category":"section"},{"location":"architecture/#Color-Mapping-and-Caching","page":"Architecture","title":"Color Mapping & Caching","text":"User input to plantviz(color=..., colormap=..., colorrange=...)\n          │\n          ▼\n  get_mtg_color / get_ref_meshes_color   get_colormap\n          │                                │\n          ▼                                ▼\n      get_color_range ◄──────────── optional user colorrange\n          │\n          ▼\nPer-node color values (or per-refmesh/per-vertex inputs)\n          │             ┌─────────────────────────────────────────┐\n          ├────────────►│ Cache: UUIDs-based attribute on MTG     │\n          │             │ (e.g., :_cache_<hash>) holds Observables│\n          ▼             └─────────────────────────────────────────┘\n Makie plot attributes (colormap, colorrange, color per vertex)\n          │\n          ▼\n        plantviz recipe renders via Meshes/Makie\n\nInputs: single color, Dict(\"RefMeshName\" => color), attribute symbol (e.g., :z_max), or per-vertex arrays. A vector of colors/symbols per node is also supported; it expands to per-face colors using the face2node mapping of the merged mesh.\nMapping: get_colormap resolves a ColorScheme; get_color_range derives or validates ranges; get_color maps values to colors.\nCaching:\nPer-node color caches (UUID-derived Observables) for interactive updates when plotting per-node geometry.\nScene cache on the root (:_scene_cache) as a single-entry NamedTuple (hash, mesh, face2node). The hash encodes the scene version and relevant options (filters). Invalidate with bump_scene_version!(mtg).","category":"section"},{"location":"architecture/#Rendering-Model-(Merged-by-Default)","page":"Architecture","title":"Rendering Model (Merged by Default)","text":"Build: traverses selected nodes, transforms ref meshes, materializes node meshes if needed, and merges them into one SimpleMesh for rendering. The merge is performed in a single pass for performance.\nColors: computes a single per-vertex color array and passes it to Makie. Attribute colors honor colormap and colorrange; dictionary inputs by refmesh are supported; per-vertex dictionaries pass through directly.\nMapping: face2node is stored alongside the merged mesh in :_scene_cache to map triangles back to node IDs. This enables expanding per-node color vectors to per-face arrays.\nUse: plantviz(opf, color=:z_max); invalidate cache after geometry/attribute changes via bump_scene_version!(opf). The merged mesh and face2node are reused across color updates.","category":"section"},{"location":"architecture/#Key-Components","page":"Architecture","title":"Key Components","text":"build_merged_mesh_with_map(mtg; ...): collects selected node meshes and returns (merged::SimpleMesh, face2node::Vector{Int}). The face2node array maps each element of the merged mesh back to its originating node id.\nScene cache helpers:\nscene_version, bump_scene_version!: version the scene to invalidate cache.\nscene_cache_key: builds a stable key for the current selection/options.\nget_cached_scene, set_cached_scene!: retrieve/store a single cached scene (hash, mesh, face2node) on the MTG root.\nPlantViz recipe (Makie): defines attributes (color, colormap, colorrange, etc.) and derives compute nodes with map! (:colorant, :colormap_resolved, :colorrange_resolved, :index_resolved). The plot calls into a helper that computes or retrieves the merged scene and computes vertex colors as needed.","category":"section"},{"location":"architecture/#Performance-Notes","page":"Architecture","title":"Performance Notes","text":"Merging: performed in one pass; avoid repeated pairwise merges. Connectivity indices are reindexed with a running vertex offset.\nface2node: built with a single preallocated vector, filling by contiguous slices per node to minimize allocations.\nColors: computed once per render and are not cached in the scene cache; only the merged mesh and face2node are cached to reduce invalidation churn.","category":"section"},{"location":"plot_diagram/plots_diagram/#Plots.jl-recipes","page":"Plots.jl","title":"Plots.jl recipes","text":"PlantGeom.jl provides recipes to make plots using Plots.jl. The only recipe so far is to make a diagram of the MTG tree. This is especially useful to control the integrity of and MTG (where it branches, where are the different scales...).\n\nTo use this recipe, simply use Plots.jl and any backend, though we recommend PlotlyJS to make the plot interactive.\n\nThe plot recipe provides some arguments to customize the plot:\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nusing Plots\n# import Pkg; Pkg.add(\"PlotlyJS\")\nplotlyjs()\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\nplot(opf, node_color = :Length)\nsavefig(\"mtgplot.html\"); nothing # hide\n\n<object type=\"text/html\" data=\"mtgplot.html\" style=\"width:100%;height:500px;\"></object>\n\nThe default plot is a 2D projection of the MTG, but you can also get a 3D projection using the mode keyword argument:\n\nplot(opf, node_color = :Length, mode = \"3d\")\nsavefig(\"mtgplot3d.html\"); nothing # hide\n\n<object type=\"text/html\" data=\"mtgplot3d.html\" style=\"width:100%;height:500px;\"></object>","category":"section"},{"location":"makie_3d/#3D-plots-(meshes)","page":"3D recipes","title":"3D plots (meshes)","text":"PlantGeom uses Makie.jl to make 3d mesh plots. It also uses MeshViz.jl that is also based on Makie.\n\nThis way the plots you make using PlantGeom support all the nice possibilities offered by Makie, such as making sub-plots, interactive plots...","category":"section"},{"location":"makie_3d/#Interactive-plot","page":"3D recipes","title":"Interactive plot","text":"Here comes the fun part! We can make 3D representations of the plants based on the geometry of each of its nodes.\n\nIf you read your MTG from an OPF file, the 3D geometry should already be computed, so you just have to plantviz() the MTG.\n\nBecause we're plotting the interactive plot in the webpage, we must use Bonito first (no need when using Julia from the REPL or VS Code):\n\nusing Bonito\nPage()\n\nThen we can plot our interactive 3D plant:\n\nusing PlantGeom, WGLMakie\nWGLMakie.activate!() # hide\nmtg = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\nplantviz(mtg)\n\nwarning: Warning\nThe plot may take some time to appear on your screen.\n\nNote that the plot is interactive. This is because we use WGLMakie as a plotting backend. You can also use GLMakie for better performance, or CairoMakie if you want a fast, non-interactive plot.","category":"section"},{"location":"makie_3d/#Colors","page":"3D recipes","title":"Colors","text":"","category":"section"},{"location":"makie_3d/#Note-about-the-backend","page":"3D recipes","title":"Note about the backend","text":"In this section, we will use the coffee plant provided as an example OPF file from the package. This one is more realistic than the tiny plant shown above. But because it is bigger, we will only provide static images instead of interactive plots. If you want to plot the interactive plots, you can execute the example code from below using GLMakie or WGLMakie instead of CairoMakie simply by replacing:\n\nusing CairoMakie\n\nBy:\n\nusing GLMakie","category":"section"},{"location":"makie_3d/#Default-colors","page":"3D recipes","title":"Default colors","text":"The default behavior of plantviz(mtg) -without providing colors- is to use the color of each reference mesh as the color of the corresponding node mesh. In other words, a leaf in a tree will be colored with the same color as the reference mesh used to represent it. This reference mesh is available as an attribute in the root node of the MTG. We can extract those reference meshes like so:\n\nusing PlantGeom, CairoMakie\nCairoMakie.activate!()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\nmtg = read_opf(file)\n\nref_meshes = get_ref_meshes(mtg)\n\nThen we can plot them in sequence:\n\nplantviz(ref_meshes)\n\nHere we are looking at the reference meshes used to build the plant. Those meshes are then transformed by transformation matrices from each node to make the mesh of that node. So by default the color used for the nodes will be taken from these reference meshes.\n\nIf we plot the coffee plant without providing any color, we would get:\n\nplantviz(mtg)","category":"section"},{"location":"makie_3d/#Single-color","page":"3D recipes","title":"Single color","text":"Now we can change the color of all meshes by providing a single color:\n\nplantviz(mtg, color = :gray87)","category":"section"},{"location":"makie_3d/#Map-color-to-reference-meshes","page":"3D recipes","title":"Map color to reference meshes","text":"We can also associate a new color to each reference mesh.\n\nWe can get the default color of each reference mesh by using:\n\nget_ref_meshes_color(ref_meshes)\n\nNow we know there are two reference meshes, one for a cylinder called \"Mesh0\" colored in brown, and a second one for the leaf that is green.\n\nTo update their colors we can simply pass the new colors as a dictionary mapping colors to the names of the reference meshes like so:\n\nplantviz(mtg, color = Dict(\"Mesh0\" => :gray87, \"Mesh1\" => \"#42A25ABD\"))\n\nIf we want to update the second reference mesh only (the leaves), we would do:\n\nplantviz(mtg, color = Dict(\"Mesh1\" => \"#42A25ABD\"))","category":"section"},{"location":"makie_3d/#Map-color-to-attributes","page":"3D recipes","title":"Map color to attributes","text":"Maybe the most interesting coloring option is to color by attribute.\n\nIndeed, each node in the MTG can have specific attributes, e.g. an area, a temperature...\n\nYou can see which attributes are available in an MTG using:\n\nprint(names(mtg))\n\nWe can see that we have an attribute called :Area. Let's color each organ by its area:\n\nplantviz(mtg, color = :Area)\n\nOf course all Makie commands are available. For example we can zoom-in the plot using scale!, and add a colorbar:\n\nf, ax, p = plantviz(mtg, color = :Area)\nCairoMakie.scale!(p, 1.5, 1.5, 1.5) # we zoom-in a little bit\nCairoMakie.Colorbar(f[1,2], label = \"Area\")\nf\n\nCairoMakie.Colorbar computations does not scale very well with very large scenes. This is why we also provide colorbar instead:\n\nf, ax, p = plantviz(mtg, color = :Area)\ncolorbar(f[1, 2], p)\nf","category":"section"},{"location":"makie_3d/#Map-color-to-vertices","page":"3D recipes","title":"Map color to vertices","text":"# Compute the z position of each vertices in each mesh:\ntransform!(mtg, (x -> [Meshes.coords(i).z for i in Meshes.vertices(refmesh_to_mesh(x))]) => :z_vertex, filter_fun= node -> hasproperty(node, :geometry))\nplantviz(mtg, color = :z_vertex, showsegments = true)\n\nnote: Note\nPer-vertex coloring is best supported with GLMakie. CairoMakie produces static outputs; WGLMakie may not render distinct vertex colors in all cases.","category":"section"},{"location":"makie_3d/#Map-time-step-to-color","page":"3D recipes","title":"Map time step to color","text":"The MTG attributes can have several values, for example a value for each time step of a simulation. For example, let's make a dummy variable with 12 time-steps, each value being the area time the time step:\n\ntransform!(mtg, :Area => (x -> [x*i for i in 1:12]) => :dummy_var, ignore_nothing = true)\n\nNow we can plot the plant with the color of each organ being the value of the dummy variable at time step 1 using the index keyword argument:\n\nf, ax, p = plantviz(mtg, color = :dummy_var, index = 1)\ncolorbar(f[1, 2], p)\nf\n\nWe can even make a video out of it:\n\nf, ax, p = plantviz(mtg, color = :dummy_var, index = 1)\ncolorbar(f[1, 2], p)\n\nrecord(f, \"coffee_steps.mp4\", 1:12, framerate=2) do timestep\n    p.index[] = timestep\nend\n\n(Image: )","category":"section"},{"location":"makie_3d/#Performance-and-Caching","page":"3D recipes","title":"Performance and Caching","text":"Merged rendering: PlantViz renders using a single merged mesh by default for responsiveness, even if geometry lives per node.\nScene cache: The merged SimpleMesh and face2node mapping are cached on the MTG root as a single entry. Re-coloring reuses the same mesh, which means the second plot will be computed more quickly.\nInvalidating: If geometry changes, you can call PlantGeom.bump_scene_version!(mtg) to invalidate the cache.\nBackends: For large scenes, prefer GLMakie for interactive work; CairoMakie for fast, static figures; WGLMakie for web.","category":"section"},{"location":"#PlantGeom","page":"Home","title":"PlantGeom","text":"Documentation for PlantGeom, a package about everything 3D-related for plants.\n\nThe package is designed around MultiScaleTreeGraph for the basic structure of plants (or any 3D object) topology and attributes.\n\nThe package provides different functionalities, the main ones being:\n\nIO for the OPF file format (see read_opf and write_opf);\nplotting using plantviz and plantviz!, optionally using coloring by attribute. Rendering is merged-by-default for performance;\nmesh transformations using transform_mesh!\n\nNote that PlantGeom reserves the :geometry attribute in the nodes (e.g. organs). It uses it to store the 3D geometry as a special structure (Geometry).\n\n(Image: )\n\nIf you want to reproduce the animation, you can look at the code below. Otherwise, please head to the next section.\n\nusing CairoMakie, Meshes, PlantGeom, MultiScaleTreeGraph\nopf = read_opf(joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\"))\n# And compute the max z of each node based on their mesh:\ntransform!(opf, zmax => :z_node, ignore_nothing = true)\n# Or the z coordinate of each vertex of each node mesh:\ntransform!(opf, (x -> [Meshes.coords(i).z for i in Meshes.vertices(refmesh_to_mesh(x))]) => :z_vertex, filter_fun= node -> hasproperty(node, :geometry))\n\n# Then we make a Makie figure:\nf = Figure()\nga = f[1, 1]\ngb = f[1, 2]\n\nax1 = Axis(ga[1, 1])\nax2 = Axis3(gb[1, 1], aspect = :data, title = \"3D representation (mesh)\", elevation = 0.15π, azimuth = 0.3π)\nhidedecorations!(ax2)\n\n# We can make a diagram out of the MTG, and coloring using the z coordinates attribute:\ndiagram!(ax1, opf, color = :z_node)\nhidedecorations!(ax1)\nax1.title = \"MultiscaleTreeGraph diagram\"\n\n# And a 3d representation:\n\nplantviz!(opf, color = :z_vertex)\n\n# And making a little animation out of it:\nCairoMakie.record(f, \"plant_animation.mp4\", 1:120) do frame\n    ax2.azimuth[] = 0.3π + 0.3 * sin(2π * frame / 120)\nend","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#PlantGeom.Geometry","page":"API","title":"PlantGeom.Geometry","text":"Geometry(; ref_mesh<:RefMesh, transformation=Identity(), dUp=1.0, dDwn=1.0)\n\nA Node geometry with the reference mesh, its transformation (as a function) and the resulting mesh (optional, may be lazily computed).\n\nThe transformation field should be a TransformsBase.Transform, such as TransformsBase.Identity, or the ones implemented in  Meshes.jl, e.g. Translate, Scale... If you already have the transformation matrix, you can pass it to Meshes.Affine(). \n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.Material","page":"API","title":"PlantGeom.Material","text":"A material for the illumination model (e.g. Phong illumination).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.Phong","page":"API","title":"PlantGeom.Phong","text":"Data structure for a mesh material that is used to describe the light components of a Phong reflection type model. All data is stored as RGBα for Red, Green, Blue and transparency.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantGeom.RefMesh","page":"API","title":"PlantGeom.RefMesh","text":"RefMesh(\n    name::S\n    mesh::SimpleMesh\n    normals::N\n    texture_coords::T\n    material::M\n    taper::Bool\n)\n\nRefMesh(name, mesh, material = RGB(220 / 255, 220 / 255, 220 / 255))\n\nRefMesh type. Stores all information about a Mesh:\n\nname::S: the mesh name\nmesh::SimpleMesh: the actual mesh information -> points and topology\nnormals::Vector{Float64}: the normals, given as a vector of x1,y1,z1,x2,y2,z2...\ntexture_coords::Vector{Float64}: the texture coordinates (not used yet), idem, a vector\nmaterial::M: the material, used to set the shading\ntaper::Bool: true if tapering is enabled\n\nThe reference meshes are then transformed on each node of the MTG using a transformation matrix to match the actual mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:PlantGeom.Geometry","page":"API","title":"Base.:==","text":"==(a::Geometry, b::Geometry)\n\nTest RefMesh equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:RefMesh","page":"API","title":"Base.:==","text":"==(a::RefMesh, b::RefMesh)\n\nTest RefMesh equality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nelements-Tuple{RefMesh}","page":"API","title":"Meshes.nelements","text":"nelements(meshes::RefMesh)\n\nReturn the number of elements of a reference mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Meshes.nvertices-Tuple{RefMesh}","page":"API","title":"Meshes.nvertices","text":"nvertices(meshes::RefMesh)\n\nReturn the number of vertices of a reference mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.align_ref_meshes-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RefMesh","page":"API","title":"PlantGeom.align_ref_meshes","text":"align_ref_meshes(meshes::Vector{<:RefMesh})\n\nAlign all reference meshes along the X axis. Used for visualisation only.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.attributes_to_xml-NTuple{4, Any}","page":"API","title":"PlantGeom.attributes_to_xml","text":"attributes_to_xml(node, xml_parent)\n\nWrite an MTG node into an XML node.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.build_merged_mesh_with_map-Tuple{Any}","page":"API","title":"PlantGeom.build_merged_mesh_with_map","text":"build_merged_mesh_with_map(mtg; filter_fun=nothing, symbol=nothing, scale=nothing, link=nothing)\n\nTraverse selected MTG nodes and merge their geometry meshes into a single Meshes.SimpleMesh.\n\nReturns a merged mesh::Meshes.SimpleMesh and a face2node::Vector{Int} mapping each face index in the merged mesh to the originating MTG node id.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.build_merged_mesh_with_map_threaded-Tuple{Any}","page":"API","title":"PlantGeom.build_merged_mesh_with_map_threaded","text":"build_merged_mesh_with_map_threaded(mtg; filter_fun=nothing, symbol=nothing, scale=nothing, link=nothing)\n\nThreaded variant of [build_merged_mesh_with_map] that parallelizes vertex copy and connectivity reindexing across meshes. Preserves original mesh order.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.bump_scene_version!-Tuple{Any}","page":"API","title":"PlantGeom.bump_scene_version!","text":"bump_scene_version!(mtg; by=1)\n\nIncrement the scene version to invalidate any cached merged scene.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.color_type-Union{Tuple{T}, Tuple{T, Any}} where T<:Symbol","page":"API","title":"PlantGeom.color_type","text":"color_type(color, opf)\n\nReturn the type of the color, whether it is an attribute, a colorant, or a RefMeshColorant.\n\nArguments\n\ncolor: The color to be checked.\nopf: The MTG to be plotted.\n\nReturns\n\nRefMeshColorantType: If color is nothing (the default) to color by reference mesh.\nDictRefMeshColorantType: If the color is a dictionary mapping reference meshes to colorants.\nDictVertexRefMeshColorantType: If the color is a dictionary mapping vertices to colorants.\nVectorColorantType: If the color is a vector of colorants, then we color each mesh by that vector.\nVectorSymbolType: If the color is a vector of symbols, then we color each mesh by that vector.\nAttributeColorantType: If the color is an attribute of the MTG, then we color by that attribute.\nT: If the color is a colorant, then we color everything by that color.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, Colors\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n\nopf = read_opf(file)\n\n# Colors:\ncolor_type(:red, opf)\ncolor_type(RGB(0.1,0.5,0.1), opf)\n\n# Attributes:\ncolor_type(:Length, opf)\n\n# Default color:\ncolor_type(nothing, opf)\n\n# Dict of colors:\ncolor_type(Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.5,0.1,0.1)), opf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.colorant_to_string-Tuple{T} where T<:ColorTypes.RGBA","page":"API","title":"PlantGeom.colorant_to_string","text":"colorant_to_string(x)\n\nParse a geometry material for OPF writing.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.coordinates!-Tuple{Any}","page":"API","title":"PlantGeom.coordinates!","text":"coordinates!(mtg; angle = 45; force = false)\n\nCompute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.\n\nReturns\n\nNothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncoordinates!(mtg)\nDataFrame(mtg, [:XX, :YY, :ZZ])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.diagram","page":"API","title":"PlantGeom.diagram","text":"diagram(opf::MultiScaleTreeGraph.Node; kwargs...)\ndiagram!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree using a Makie.jl backend.\n\ndanger: Danger\nThis function is an extension to the package. It is only available if you imported a Makie backend (e.g. using GLMakie) prior to using PlantGeom.\n\nThe main attributes are:\n\ncolor: the color of the nodes\ncolormap: the colormap used if the color uses an attribute. By default it uses viridis.\n\nMust be a ColorScheme from ColorSchemes or a Symbol with its name.\n\nExamples\n\nusing GLMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\ndiagram(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\ndiagram(opf, color = :red)\n\n# Or colouring by opf attribute, *e.g.* using the nodes Z coordinates:\ndiagram(opf, color = :ZZ)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.diagram!","page":"API","title":"PlantGeom.diagram!","text":"diagram(opf::MultiScaleTreeGraph.Node; kwargs...)\ndiagram!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree using a Makie.jl backend.\n\ndanger: Danger\nThis function is an extension to the package. It is only available if you imported a Makie backend (e.g. using GLMakie) prior to using PlantGeom.\n\nThe main attributes are:\n\ncolor: the color of the nodes\ncolormap: the colormap used if the color uses an attribute. By default it uses viridis.\n\nMust be a ColorScheme from ColorSchemes or a Symbol with its name.\n\nExamples\n\nusing GLMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\ndiagram(opf)\n\n# We can also color the 3d plot with several options:\n# With one shared color:\ndiagram(opf, color = :red)\n\n# Or colouring by opf attribute, *e.g.* using the nodes Z coordinates:\ndiagram(opf, color = :ZZ)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.extend_pos-NTuple{5, Any}","page":"API","title":"PlantGeom.extend_pos","text":"Add a new point after (x1,y1) using same direction and length relative to it\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_attr_type-Tuple{Any}","page":"API","title":"PlantGeom.get_attr_type","text":"Get the attributes types in Julia DataType.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_cached_scene-Tuple{Any, Any}","page":"API","title":"PlantGeom.get_cached_scene","text":"get_cached_scene(mtg, key) -> Union{Nothing,NamedTuple}\n\nRetrieve the single cached merged scene if it matches key. Returns a NamedTuple with (hash, mesh, face2node) or nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_color-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Nothing}} where T<:AbstractArray","page":"API","title":"PlantGeom.get_color","text":"get_color(var <: AbstractArray, range_var, colormap=colorschemes[:viridis])\nget_color(var, range_var, colormap=colorschemes[:viridis])\n\nMap value(s) to colors from a colormap based on a range of values\n\nArguments\n\nvar: value(s) to map to colors\nrange_var: range of values to map to colors\ncolormap: colormap to use\n\nReturns\n\ncolor: color(s) corresponding to var\n\nExamples\n\nusing Colors\n\nget_color(1, 1:2, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415)\nget_color(1:2, 1:10, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415)\nget_color(1:2, 1:10, 1, colormap = colorschemes[:viridis]) # returns RGB{N0f8}(0.267004,0.00487433,0.329415)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_color_range-Tuple{Nothing, Any, PlantGeom.AttributeColorant}","page":"API","title":"PlantGeom.get_color_range","text":"get_color_range(colorrange, opf, colorant)\n\nGet the color range from the colorrange argument or from the MTG attribute.\n\nArguments\n\ncolorrange: the color range specified by the user, can be an Observable or a tuple of two values.\nopf: the MTG object.\ncolorant: the color attribute to use for the range.\n\nReturns\n\ncolorrange: the color range as a tuple of two values.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_colormap-Tuple{Any}","page":"API","title":"PlantGeom.get_colormap","text":"get_colormap(colormap)\n\nGet the colormap as a ColorScheme if it is a named color or ColorScheme\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_mtg_color-Tuple{Any, Any}","page":"API","title":"PlantGeom.get_mtg_color","text":"get_mtg_color(color, opf)\n\nReturn the color to be used for the plot.\n\nArguments\n\ncolor: The color to be checked.\nopf: The MTG to be plotted.\n\nReturns\n\nThe color to be used for the plot.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, Colors\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nget_mtg_color(:red, opf)\nget_mtg_color(RGB(0.1,0.5,0.1), opf)\nget_mtg_color(:Length, opf)\nget_mtg_color(:slategray3, opf)\nget_mtg_color(Dict(1=>RGB(0.1,0.5,0.1), 2=>RGB(0.1,0.1,0.5)), opf)\nget_mtg_color(Dict(1 => :burlywood4, 2 => :springgreen4), opf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_mesh_name-Tuple{Any}","page":"API","title":"PlantGeom.get_ref_mesh_name","text":"get_ref_mesh_name(node)\n\nGet the name of the reference mesh used for the current node.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_meshes-Tuple{Any}","page":"API","title":"PlantGeom.get_ref_meshes","text":"get_ref_meshes(mtg)\n\nGet all reference meshes from an mtg, usually from an OPF.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\n\nusing GLMakie\nplantviz(meshes)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.get_ref_meshes_color-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RefMesh","page":"API","title":"PlantGeom.get_ref_meshes_color","text":"get_ref_meshes_color(meshes::Vector{<:RefMesh})\n\nGet the reference meshes colors (only the diffuse part for now).\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshes = get_ref_meshes(opf)\nPlantGeom.get_ref_meshes_color(meshes)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.map_coord-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.map_coord","text":"map_coord(f, mesh, coord)\n\nApply function f over the mesh coordinates coord. Values for coord can be 1 for x, 2 for y and 3 for z.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.materialBDD_to_material-Tuple{Any}","page":"API","title":"PlantGeom.materialBDD_to_material","text":"Parse a material in opf format to a Phong material.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.material_to_opf_string-Tuple{Phong}","page":"API","title":"PlantGeom.material_to_opf_string","text":"material_to_opf_string(material::Phong)\nmaterial_to_opf_string(material::Colorant)\n\nFormat a material into a Dict for OPF writting.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.merge_children_geometry!-Tuple{Any}","page":"API","title":"PlantGeom.merge_children_geometry!","text":"merge_children_geometry!(mtg; from, into, delete=:nodes, verbose=true, child_link_fun=x -> new_child_link(x, verbose))\n\nSimplifies the geometry of a MultiScaleTreeGraph (MTG) by merging low-scale geometries into an higher-scale geometry.\n\nArguments\n\nmtg: The MultiScaleTreeGraph to process.\nfrom: The string for the type of nodes to simplify, this is the lower scale meshes that need to be merged. Can be a string or a vector of strings, e.g. [\"Petiole\", \"Rachis\"].\ninto: The string for the type of nodes to merge into. Must be a single string, e.g. \"Leaf\".\ndelete: A symbol indicating whether to delete the nodes or the geometry after merging:\n:none: No deletion will be performed, the geometry is merged into the into nodes, and also kept as before in the from nodes.\n:nodes: The nodes of type from will be deleted after merging.\n:geometry: Only the geometry will be deleted, but the from nodes will remain in the MTG.\nverbose: A boolean indicating if information should be returned when nodes or geometry was not found on expected nodes\nchild_link_fun: A function that takes a parent node targeted for deletion and returns the new links for their children. Required if delete is true. The\n\ndefault function is new_child_link, which tries to be clever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the link function instead.\n\nReturns\n\nNothing. The function modifies the mtg in place.\n\nNotes\n\nIf no geometry is found in the children nodes of type from, an informational message is logged.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.merge_simple_meshes-Tuple{AbstractVector{<:SimpleMesh}}","page":"API","title":"PlantGeom.merge_simple_meshes","text":"merge_simple_meshes(meshes::AbstractVector{<:Meshes.SimpleMesh}) -> Meshes.SimpleMesh\n\nMerge a collection of Meshes.SimpleMesh into a single mesh in one pass by concatenating vertices and reindexing element connectivities with running offsets. This avoids repeated pairwise merges and additional allocations.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.meshBDD_to_meshes-Tuple{Any}","page":"API","title":"PlantGeom.meshBDD_to_meshes","text":"meshBDD_to_meshes(x)\n\nExamples\n\nusing MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nmeshBDD_to_meshes(opf[:meshBDD])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.mtg_coordinates_df","page":"API","title":"PlantGeom.mtg_coordinates_df","text":"mtg_coordinates_df(mtg, attr; force = false)\nmtg_coordinates_df!(mtg, attr; force = false)\n\nExtract the coordinates of the nodes of the mtg and the coordinates of their parents (:XXfrom, :YYfrom, :ZZ_from) and output a DataFrame. Optionally you can also provide an attribute to add to the output DataFrame too by passing its name as a symbol to attr.\n\nThe coordinates are computed using coordinates! if missing, or if force = true.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.mtg_to_opf_link-Tuple{Any}","page":"API","title":"PlantGeom.mtg_to_opf_link","text":"mtg_to_opf_link(link)\n\nTakes an MTG link as input (\"/\", \"<\" or \"+\") and outputs its corresponding link as declared in the OPF format (\"decomp\", \"follow\" or \"branch\")\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.mtg_topology_to_xml!","page":"API","title":"PlantGeom.mtg_topology_to_xml!","text":"mtg_topology_to_xml!(node, xml_parent)\n\nWrite the MTG topology, attributes and geometry into XML format. This function is used to write the \"topology\" section of the OPF.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.normals_vertex-Tuple{RefMesh}","page":"API","title":"PlantGeom.normals_vertex","text":"normals_vertex(mesh::Meshes.SimpleMesh)\n\nCompute per vertex normals and return them as a StaticArrays.SVector.\n\n#! This is a naive approach because I have no time right know. #! We just put the face mesh as a vertex mesh (and ovewritting values for common points)\n\nTODO: Use a real computation instead. See e.g.:\n\nhttps://stackoverflow.com/questions/45477806/general-method-for-calculating-smooth-vertex-normals-with-100-smoothness?noredirect=1&lq=1\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_geometry-Tuple{Any}","page":"API","title":"PlantGeom.parse_geometry","text":"Parse the geometry element of the OPF.\n\nNote\n\nThe transformation matrix is 3*4. elem = elem.content\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_materialBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_materialBDD!","text":"Parse the materialBDD using parse_opf_elements!\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_meshBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_meshBDD!","text":"Parse the meshBDD using parse_opf_array\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_array","page":"API","title":"PlantGeom.parse_opf_array","text":"Parse an array of values from the OPF into a Julia array (Arrays in OPFs are not following XML recommendations)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.parse_opf_attributeBDD!-Tuple{Any}","page":"API","title":"PlantGeom.parse_opf_attributeBDD!","text":"Parse the opf attributes as a Dict.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_elements!-Tuple{Any, Any}","page":"API","title":"PlantGeom.parse_opf_elements!","text":"Generic parser for OPF elements.\n\nArguments\n\nopf::OrderedDict: the opf Dict (using [XMLDict.xml_dict])\nelem_types::Array: the target types of the element (e.g. \"[String, Int64]\")\n\nDetails\n\nelem_types should be of the same length as the number of elements found in each item of the subchild. elem_types = [Float64, Float64, Float64, Float64, Float64, Float64]\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.parse_opf_topology!","page":"API","title":"PlantGeom.parse_opf_topology!","text":"parse_opf_topology!(node, mtg, features, attr_type, mtg_type, ref_meshes, id_set=Set{Int}())\n\nParser of the OPF topology.\n\nArguments\n\nnode::ElementNode: the XML node to parse.\nmtg::Union{Nothing,Node}: the parent MTG node.\nfeatures::Dict: the features of the OPF.\nattr_type::DataType: the type of the attributes to use.\nmtg_type::DataType: the type of the MTG to use.\nref_meshes::Dict: the reference meshes.\nread_id::Bool: whether to read the ID from the OPF or recompute it on the fly.\nmax_id::RefValue{Int64}=Ref(1): the ID of the first node, if read_id==false.\n\nNote\n\nThe transformation matrices in geometry are 3*4.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.parse_ref_meshes-Tuple{Any}","page":"API","title":"PlantGeom.parse_ref_meshes","text":"parse_ref_meshes(mtg)\n\nParse the reference meshes of an OPF into RefMeshes.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.plantviz","page":"API","title":"PlantGeom.plantviz","text":"plantviz(mtg::MultiScaleTreeGraph.Node; kwargs...)\nplantviz!(mtg::MultiScaleTreeGraph.Node; kwargs...)\n\nVizualise the 3D geometry of an MTG (usually read from an OPF). This function search for the :geometry attribute in each node of the MTG, and build the vizualisation using the reference meshes and the associated transformation matrix.\n\nArguments\n\nmtg: The MTG to be vizualised.\nkwargs: Additional arguments to be passed to plantviz!, wich includes: \ncolor: The color to be used for the plot. Can be a colorant, an attribute of the MTG (given as a Symbol), or a dictionary of colors for each reference mesh.\ncolormap: The colorscheme to be used for the plot. Can be a Symbol or a ColorScheme. \nsegmentcolor: The color to be used for the facets. Should be a colorant or a symbol of color.\nshowsegments: A boolean indicating whether the facets should be shown or not.\ncolor_missing=RGBA(0, 0, 0, 0.3): The color to be used for missing values. Should be a colorant or a symbol of color.\nindex: An integer giving the index of the attribute value to be vizualised. This is useful when the attribute is a vector of values for e.g. each timestep.\ncolor_cache_name: The name of the color cache. Should be a string (default to a random string).\nfilter_fun: A function to filter the nodes to be plotted. Should be a function taking a node as argument and returning a boolean.\nsymbol: Plot only nodes with this symbol. Should be a String or a vector of.\nscale: Plot only nodes with this scale. Should be an Int or a vector of.\nlink: Plot only nodes with this link. Should be a String or a vector of.\n\nExamples\n\nusing MultiScaleTreeGraph, PlantGeom, GLMakie\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nmtg = read_opf(file)\nplantviz(mtg)\n\n# Then plot it again like before, and it will be faster:\nplantviz(mtg)\n\n# We can color the 3d plot with several options:\n# With one shared color:\nplantviz(mtg, color = :red)\n# One color per reference mesh:\nplantviz(mtg, color = Dict(1 => :burlywood4, 2 => :springgreen4, 3 => :burlywood4))\n\n# Or just changing the color of some:\nplantviz(mtg, color = Dict(1 => :burlywood4))\n\n# Or coloring by mtg attribute, e.g. using the mesh max Z coordinates:\ntransform!(mtg, zmax => :z_max, ignore_nothing = true)\nplantviz(mtg, color = :z_max)\n\n# One color for each vertex of the refmesh 1:\nusing Meshes\nvertex_color = get_color(1:nvertices(get_ref_meshes(mtg))[1], [1,nvertices(get_ref_meshes(mtg))[1]])\nplantviz(mtg, color = Dict(1 => vertex_color))\n\n# Or even coloring by the value of the Z coordinates of each vertex:\ntransform!(mtg, (x -> [Meshes.coords(i).z for i in Meshes.vertices(refmesh_to_mesh(x))]) => :z_vertex, filter_fun= node -> hasproperty(node, :geometry))\nplantviz(mtg, color = :z, showsegments = true)\n\nf,a,p = plantviz(mtg, color = :z, showsegments = true)\np[:color] = :Length\n\nplantviz!(ref_meshes; kwargs...)\n\nPlot all reference meshes in a single 3d plot using Makie.\n\nExamples\n\nusing PlantGeom, GLMakie\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nmtg = read_opf(file)\nmeshes = get_ref_meshes(mtg)\n\nplantviz(meshes)\n# With one shared color:\nplantviz(meshes, color = :green)\n# One color per reference mesh:\nplantviz(meshes, color = Dict(1 => :burlywood4, 2 => :springgreen4, 3 => :burlywood4))\n# Or just changing the color of some:\nplantviz(meshes, color = Dict(1 => :burlywood4, 3 => :burlywood4))\n# One color for each vertex of the refmesh 0:\nplantviz(meshes, color = Dict(2 => 1:nvertices(meshes)[2]))\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.plantviz!","page":"API","title":"PlantGeom.plantviz!","text":"viplantviz!(mtg; [options])\n\nVisualize the 3D meshes of an mtg using Meshes.jl and makie. This function adds the plot to an existing scene with options forwarded to plantviz.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.read_opf-Tuple{Any}","page":"API","title":"PlantGeom.read_opf","text":"read_opf(file; attr_type = Dict, mtg_type = MutableNodeMTG)\n\nRead an OPF file, and returns an MTG.\n\nArguments\n\nfile::String: The path to the opf file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nread_id::Bool = true: whether to read the ID from the OPF or recompute it on the fly.\nmax_id::RefValue{Int64}=Ref(1): the ID of the first node, if read_id==false.\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attributes a lot\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify  anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the MTG package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\nopf = read_opf(file)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_ops-Tuple{Any}","page":"API","title":"PlantGeom.read_ops","text":"read_ops(file; attr_type=Dict{String,Any}, mtg_type=MutableNodeMTG)\n\nReads an OPS file and returns the content as a MultiScaleTreeGraph.\n\nArguments\n\nfile::String: Path of the .ops file to read.\nattr_type::Type=Dict{Symbol,Any}: Type of the attributes to use.\nmtg_type::Type: Type of the MTG to use, e.g. NodeMTG or MutableNodeMTG.\n\nReturns\n\nA MultiScaleTreeGraph of the scene, with the OPFs as children of the scene node. The dimension of the scene is available in the scene_dimensions attribute of the scene node. Each root node of the OPFs has a scene_transformation attribute that stores the transformation applied to the OPF by the scene. It allows updating the scene transformations and write the scene back to disk. The OPF root node also has the following attributes:\n\nsceneID::Int: Scene ID.\nplantID::Int: Plant ID.\nfilePath::String: Path to the original .opf file.\npos::Meshes.Point: Position of the object.\nscale::Float64: Scale of the object.\ninclinationAzimut::Float64: Inclination azimut of the object.\ninclinationAngle::Float64: Inclination angle of the object.\nrotation::Float64: Rotation of the object.\nfunctional_group::String: Functional group of the object.\n\nDetails\n\nNode IDs of the OPFs are recomputed at import to ensure their uniqueness in the larger scene MTG.\n\nExample\n\nusing CairoMakie, PlantGeom\njoinpath(pathof(PlantGeom) |> dirname |> dirname, \"test\", \"files\", \"scene.ops\") |> read_ops |> plantviz\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.read_ops_file-Tuple{Any}","page":"API","title":"PlantGeom.read_ops_file","text":"read_ops_file(file)\n\nRead the content of an .ops file and return a tuple with the scene dimensions and the object table.\n\nArguments\n\nfile::String: Path of the .ops file to read.\n\nReturns\n\nThe scene dimensions and the object table as a tuple. The scene dimensions are a tuple of two Meshes.Point with the origin point and opposite point of the scene.  The object table is an array of NamedTuple with the following fields:\n\nsceneID::Int: Scene ID.\nplantID::Int: Plant ID.\nfilePath::String: Path to the .opf file.\npos::Meshes.Point: Position of the object.\nscale::Float64: Scale of the object.\ninclinationAzimut::Float64: Inclination azimut of the object.\ninclinationAngle::Float64: Inclination angle of the object.\nrotation::Float64: Rotation of the object.\nfunctional_group::String: Functional group of the object.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.refmesh_to_mesh","page":"API","title":"PlantGeom.refmesh_to_mesh","text":"refmesh_to_mesh(node)\n\nCompute a node mesh based on the reference mesh, the transformation matrix and the tapering.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\n\nnode = opf[1][1][1]\n\nnew_mesh = refmesh_to_mesh(node)\n\nusing GLMakie\nplantviz(new_mesh)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.rotate_point-NTuple{5, Any}","page":"API","title":"PlantGeom.rotate_point","text":"Rotate a point (x1,y1) around (x0, y0) with angle.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.scene_cache_key-Tuple{Any}","page":"API","title":"PlantGeom.scene_cache_key","text":"scene_cache_key(mtg; symbol=nothing, scale=nothing, link=nothing, filter_fun=nothing) -> UInt\n\nCompute a stable cache key for the current scene rendering request.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.scene_version-Tuple{Any}","page":"API","title":"PlantGeom.scene_version","text":"scene_version(mtg) -> Int\n\nReturn the scene version counter stored on the MTG root (default 0).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.set_cached_scene!-Tuple{Any, Any}","page":"API","title":"PlantGeom.set_cached_scene!","text":"set_cached_scene!(mtg, key; mesh, face2node=nothing)\n\nStore a single merged scene cache with associated key hash. Only mesh and face2node are cached.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.taper-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.taper","text":"Returns a tapered mesh using dDwn and dUp based on the geometry of an input mesh. Tapering a mesh transforms it into a tapered version (i.e. pointy) or enlarged object, e.g. make a cone from a cylinder.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.transform_mesh!-Tuple{MultiScaleTreeGraph.Node, Any}","page":"API","title":"PlantGeom.transform_mesh!","text":"transform_mesh!(node::Node, transformation)\n\nAdd a new transformation to the node geometry transformation field.  The transformation is composed with the previous transformation if any.\n\ntransformation must be a function.\n\nIt is also possible to invert a transformation using revert from Meshes.jl.\n\nExamples\n\nusing PlantGeom, MultiScaleTreeGraph, GLMakie, Rotations, Meshes\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))), \"test\", \"files\", \"simple_plant.opf\")\nopf = read_opf(file)\n\n# Visualize the mesh as is:\nplantviz(opf)\n\n# Copy the OPF, and translate the whole plant by 15 in the y direction (this is in cm, the mesh comes from XPlo):\nclean_cache!(opf) # Clean the cache to remove the observables that where cached by the previous `plantviz` call (necessary for the `deepcopy`).\nopf2 = deepcopy(opf)\ntransform!(opf2, x -> transform_mesh!(x, Translate(0, 15, 0)))\nplantviz!(opf2) # Visualize it again in the same figure\n\n# Same but rotate the whole plant around the X axis:\nclean_cache!(opf)\nopf3 = deepcopy(opf)\ntransform!(opf3, x -> transform_mesh!(x, Rotate(RotX(0.3))))\n# NB: we use Rotations.jl's RotX here. Input in radian, use rad2deg and deg2rad if needed.\nplantviz!(opf3)\n\n# Same but rotate only the second leaf around the Z axis:\nclean_cache!(opf)\nopf4 = deepcopy(opf)\n\n# Get the second leaf in the OPF:\nleaf_node = get_node(opf4, 8)\n\n# Get the parent node (internode) Z coordinates:\nparent_zmax = zmax(leaf_node.parent)\n\n# Define a rotation of the mesh around the Z axis defined by the parent node max Z:\ntransformation = recenter(Rotate(RotZ(1.0)), Point(0.0, 0.0, parent_zmax))\n\n# Update the transformation matrix of the leaf and its mesh:\ntransform_mesh!(leaf_node, transformation)\n\n# Plot the result:\nplantviz(opf)\nplantviz!(opf4)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.write_opf-Tuple{Any, Any}","page":"API","title":"PlantGeom.write_opf","text":"write_opf(file, opf)\n\nWrite an MTG with explicit geometry to disk as an OPF file.\n\nNotes\n\nNode attribute :geometry is treated as a reserved keyword and should not be used without knowing their meaning.\n\nExamples\n\nusing PlantGeom\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\nopf = read_opf(file)\nwrite_opf(\"test.opf\", opf)\nopf2 = read_opf(\"test.opf\")\nplantviz(opf2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.write_ops-Tuple{Any, Any, Any}","page":"API","title":"PlantGeom.write_ops","text":"write_ops(file, scene_dimensions, object_table)\n\nWrite a scene file (.ops), with the given dimensions and object table.\n\nArguments\n\nfile::String: Path of the .ops file to write.\nscene_dimensions::Tuple{Meshes.Point{3,T},Meshes.Point{3,T}}: Dimensions of the scene.\nobject_table: Table with the objects to write in the .ops file. The table may have the following columns:\nsceneID::Int: Scene ID (mandatory).\nplantID::Int: Plant ID (mandatory).\nfilePath::String: Path to the .opf file (mandatory).\npos::Meshes.Point{3,T}: Position of the object (mandatory).\nfunctional_group::String: Functional group of the object, used to map the object to the models (mandatory).\nscale::T: Scale of the object (optional, 0.0 as default).\ninclinationAzimut::T: Inclination azimut of the object (optional, 0.0 as default).\ninclinationAngle::T: Inclination angle of the object (optional, 0.0 as default).\nrotation::T: Rotation of the object (optional, 0.0 as default).\n\nDetails\n\nobject_table can be of any format that implement the Tables.jl interface, e.g. an array of NamedTuples, a DataFrame...\n\nExample\n\nusing Meshes\nusing Tables\nusing PlantGeom\n\nscene_dimensions = (Meshes.Point(0.0, 0.0, 0.0), Meshes.Point(100.0, 100.0, 100.0))\npositions = [Meshes.Point(50.0, 50.0, 50.0), Meshes.Point(60.0, 60.0, 60.0), Meshes.Point(70.0, 70.0, 70.0)]\nobject_table = [\n    (sceneID=1, plantID=p, filePath=\"opf/plant_$p.opf\", pos=positions[p], functional_group=\"plant\", rotation=0.1) for p in 1:3\n]\n\nwrite_ops(\"scene.ops\", scene_dimensions, object_table)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantGeom.xmax","page":"API","title":"PlantGeom.xmax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.xmin","page":"API","title":"PlantGeom.xmin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.ymax","page":"API","title":"PlantGeom.ymax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.ymin","page":"API","title":"PlantGeom.ymin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.zmax","page":"API","title":"PlantGeom.zmax","text":"xmax(x)\nymax(x)\nzmax(x)\n\nGet the maximum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantGeom.zmin","page":"API","title":"PlantGeom.zmin","text":"xmin(x)\nymin(x)\nzmin(x)\n\nGet the minimum x, y or z coordinates of a mesh or a Node.\n\n\n\n\n\n","category":"function"},{"location":"API/#RecipesBase.plot","page":"API","title":"RecipesBase.plot","text":"plot(opf::MultiScaleTreeGraph.Node; kwargs...)\nplot!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree, paired with a Plots.jl backend.\n\nSee also diagram for the same plot with a Makie.jl backend.\n\nAttributes\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nExamples\n\n# import Pkg; Pkg.add(\"PlotlyJS\")\nusing Plots, PlantGeom\nplotlyjs()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\nplot(opf, node_color = :Length)\n\n\n\n\n\n","category":"function"},{"location":"API/#RecipesBase.plot!","page":"API","title":"RecipesBase.plot!","text":"plot(opf::MultiScaleTreeGraph.Node; kwargs...)\nplot!(opf::MultiScaleTreeGraph.Node; kwargs...)\n\nMake a diagram of the MTG tree, paired with a Plots.jl backend.\n\nSee also diagram for the same plot with a Makie.jl backend.\n\nAttributes\n\nmode = \"2d\": The mode for plotting, either \"2d\" or \"3d\"\nnode_color = :black: the node color, can be a color or any MTG attribute\nedge_color = node_color: same as node_color, but for the edges\ncolormap = :viridis: the colormap used for coloring\ncolor_missing = RGBA(0, 0, 0, 0.3): The color used for missing values\n\nExamples\n\n# import Pkg; Pkg.add(\"PlotlyJS\")\nusing Plots, PlantGeom\nplotlyjs()\n\nfile = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"simple_plant.opf\")\n# file = joinpath(dirname(dirname(pathof(PlantGeom))),\"test\",\"files\",\"coffee.opf\")\n\nopf = read_opf(file)\n\nplot(opf, node_color = :Length)\n\n\n\n\n\n","category":"function"}]
}
